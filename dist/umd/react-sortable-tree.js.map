{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///react-sortable-tree.js","webpack:///webpack/bootstrap ad000d290dee929048c1","webpack:///./src/index.js","webpack:///./src/utils/tree-data-utils.js","webpack:///./~/css-loader/lib/css-base.js","webpack:///./~/style-loader/addStyles.js","webpack:///external \"prop-types\"","webpack:///external \"react\"","webpack:///./src/utils/default-handlers.js","webpack:///./src/utils/memoized-tree-data-utils.js","webpack:///./src/node-renderer-default.js","webpack:///./src/react-sortable-tree.js","webpack:///./src/tree-node.js","webpack:///./src/utils/browser-utils.js","webpack:///./src/utils/drag-and-drop-utils.js","webpack:///./src/utils/generic-utils.js","webpack:///./~/react-virtualized/styles.css","webpack:///./src/node-renderer-default.scss","webpack:///./src/react-sortable-tree.scss","webpack:///./src/tree-node.scss","webpack:///./~/react-virtualized/styles.css?2461","webpack:///./src/node-renderer-default.scss?a913","webpack:///./src/react-sortable-tree.scss?eb15","webpack:///./src/tree-node.scss?1e60","webpack:///external \"lodash.isequal\"","webpack:///external \"react-dnd\"","webpack:///external \"react-dnd-html5-backend\"","webpack:///external \"react-dnd-scrollzone\"","webpack:///external \"react-virtualized\""],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_4__","__WEBPACK_EXTERNAL_MODULE_5__","__WEBPACK_EXTERNAL_MODULE_22__","__WEBPACK_EXTERNAL_MODULE_23__","__WEBPACK_EXTERNAL_MODULE_24__","__WEBPACK_EXTERNAL_MODULE_25__","__WEBPACK_EXTERNAL_MODULE_26__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","SortableTreeWithoutDndContext","undefined","_defaultHandlers","keys","forEach","key","enumerable","get","_treeDataUtils","_reactSortableTree","_reactSortableTree2","_toConsumableArray","arr","Array","isArray","i","arr2","length","from","getNodeDataAtTreeIndexOrNextIndex","_ref","targetIndex","node","currentIndex","getNodeKey","_ref$path","path","_ref$lowerSiblingCoun","lowerSiblingCounts","_ref$ignoreCollapsed","ignoreCollapsed","_ref$isPseudoRoot","isPseudoRoot","selfPath","concat","treeIndex","children","expanded","nextIndex","childIndex","childCount","result","getDescendantCount","_ref2","_ref2$ignoreCollapsed","walkDescendants","_ref3","callback","_ref3$isPseudoRoot","_ref3$parentNode","parentNode","_ref3$path","_ref3$lowerSiblingCou","selfInfo","callbackResult","mapDescendants","_ref4","_ref4$isPseudoRoot","_ref4$parentNode","_ref4$path","_ref4$lowerSiblingCou","nextNode","map","child","mapResult","getVisibleNodeCount","_ref5","treeData","traverse","reduce","total","currentNode","getVisibleNodeInfoAtIndex","_ref6","index","walk","_ref7","_ref7$ignoreCollapsed","_ref8","_ref8$ignoreCollapsed","toggleExpandedForAll","_ref9","_ref9$expanded","_ref10","_extends","_ref11","changeNodeAtPath","_ref12","newNode","_ref12$ignoreCollapse","RESULT_MISS","_ref13","_ref13$isPseudoRoot","currentTreeIndex","pathIndex","Error","nextTreeIndex","slice","removeNodeAtPath","_ref14","_ref14$ignoreCollapse","getNodeAtPath","_ref15","_ref15$ignoreCollapse","foundNodeInfo","_ref16","err","addNodeUnderParent","_ref17","_ref17$parentKey","parentKey","_ref17$ignoreCollapse","_ref17$expandParent","expandParent","insertedTreeIndex","hasBeenAdded","changedTreeData","_ref18","addNodeAtDepthAndIndex","_ref19","targetDepth","minimumTreeIndex","_ref19$isPseudoRoot","isLastChild","currentDepth","_ref19$path","n","extraNodeProps","parentPath","insertIndex","pathFragment","newChildren","insertNode","_ref20","depth","_ref20$getNodeKey","_ref20$ignoreCollapse","_ref20$expandParent","insertResult","getFlatDataFromTree","_ref21","_ref21$ignoreCollapse","flattened","nodeInfo","push","getTreeFromFlatData","_ref22","flatData","_ref22$getKey","getKey","_ref22$getParentKey","getParentKey","parentId","_ref22$rootKey","rootKey","childrenToParents","trav","parent","isDescendant","older","younger","some","getDepth","arguments","deepest","Math","max","find","_ref23","searchQuery","searchMethod","searchFocusOffset","_ref23$expandAllMatch","expandAllMatchPaths","_ref23$expandFocusMat","expandFocusMatchPaths","matchCount","_ref24","_ref24$isPseudoRoot","_ref24$path","matches","isSelfMatch","hasFocusMatch","extraInfo","hasChildren","match","assign","target","source","prototype","hasOwnProperty","cssWithMappingToString","item","useSourceMap","content","cssMapping","btoa","sourceMapping","toComment","sourceURLs","sources","sourceRoot","join","sourceMap","base64","unescape","encodeURIComponent","JSON","stringify","data","list","toString","mediaQuery","alreadyImportedModules","addStylesToDom","styles","options","domStyle","stylesInDom","refs","j","parts","addStyle","listToStyles","newStyles","css","media","part","insertStyleElement","styleElement","head","getHeadElement","lastStyleElementInsertedAtTop","styleElementsInsertedAtTop","insertAt","nextSibling","insertBefore","appendChild","firstChild","removeStyleElement","removeChild","idx","indexOf","splice","createStyleElement","document","createElement","type","createLinkElement","linkElement","rel","update","remove","singleton","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","bind","URL","createObjectURL","revokeObjectURL","Blob","updateLink","href","applyToTag","newObj","styleSheet","cssText","replaceText","cssNode","createTextNode","childNodes","setAttribute","blob","oldSrc","memoize","fn","memo","apply","isOldIE","test","self","navigator","userAgent","toLowerCase","getElementsByTagName","newList","mayRemove","textStore","replacement","filter","Boolean","defaultGetNodeKey","getReactElementText","_typeof","props","stringSearch","String","defaultSearchMethod","Symbol","iterator","constructor","memoizedInsertNode","args","keysArray","sort","argsArray","memoizedInsertArgsArray","arg","memoizedInsertKeysArray","memoizedInsertResult","_objectWithoutProperties","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","ReferenceError","_inherits","subClass","superClass","create","writable","configurable","setPrototypeOf","__proto__","_createClass","defineProperties","descriptor","protoProps","staticProps","_react","_react2","_propTypes","_propTypes2","_browserUtils","_nodeRendererDefault","_nodeRendererDefault2","getIEVersion","row","row_NoFlex","rowContents","rowContents_NoFlex","rowLabel","rowLabel_NoFlex","rowToolbar","rowToolbar_NoFlex","NodeRendererDefault","_Component","getPrototypeOf","_props","scaffoldBlockPxWidth","toggleChildrenVisibility","connectDragPreview","connectDragSource","isDragging","canDrop","canDrag","draggedNode","isSearchMatch","isSearchFocus","buttons","className","_props$style","style","didDrop","otherProps","isOver","endDrag","startDrag","handle","loadingHandle","loadingCircle","loadingCirclePoint","moveHandle","dropEffect","isDraggedDescendant","isLandingPadActive","height","aria-label","collapseButton","expandButton","left","onClick","width","lineChildren","rowWrapper","rowLandingPad","rowCancelPad","rowSearchMatch","rowSearchFocus","opacity","rowContentsDragDisabled","rowTitle","subtitle","rowTitleWithSubtitle","title","rowSubtitle","btn","toolbarButton","Component","propTypes","object","isRequired","arrayOf","oneOfType","string","number","bool","func","_reactVirtualized","_lodash","_lodash2","_reactDndScrollzone","_reactDndScrollzone2","_treeNode","_treeNode2","_memoizedTreeDataUtils","_genericUtils","_dragAndDropUtils","dndTypeCounter","ReactSortableTree","_this","dndType","nodeContentRenderer","isVirtualized","slideRegionSize","dndWrapSource","treeNodeRenderer","dndWrapTarget","scrollZoneVirtualList","List","vStrength","createVerticalStrength","hStrength","createHorizontalStrength","state","draggingTreeData","swapFrom","swapLength","swapDepth","rows","getRows","searchMatches","searchFocusTreeIndex","moveNode","dragHover","loadLazyChildren","search","ignoreOneTreeUpdate","targetNode","onChange","onVisibilityToggle","_insertNode","onMoveNode","nextProps","setState","seekIndex","expand","singleSearch","searchFinishCallback","_find","expandedTreeData","freeze","addedResult","expandedParentPath","swapTo","swapRows","dropResult","_this2","loadCollapsedLazyChildren","done","childrenArray","oldNode","_this3","innerStyle","rowHeight","_state","matchKeys","scrollToInfo","scrollToIndex","containerStyle","ScrollZoneVirtualList","AutoSizer","verticalStrength","horizontalStrength","speed","scrollToAlignment","virtualScrollOverride","onScroll","scrollTop","rowCount","estimatedRowSize","rowRenderer","rowStyle","renderRow","reactVirtualizedListProps","tree","listIndex","getPrevRow","_props2","generateNodeProps","maxDepth","TreeNodeRenderer","NodeContentRenderer","nodeKey","callbackParams","nodeProps","rowCanDrag","customCanDrop","any","defaultProps","dndWrapRoot","TreeNode","connectDropTarget","scaffoldBlockCount","scaffold","lowerSiblingCount","lineClass","lineHalfHorizontalRight","lineHalfVerticalBottom","lineFullVertical","lineHalfVerticalTop","lineBlock","highlightLineClass","highlightBottomLeftCorner","highlightTopLeftCorner","highlightLineVertical","absoluteLineBlock","nodeContent","Children","cloneElement","array","parseInt","getTargetDepth","dropTargetProps","monitor","dropTargetDepth","draggedItem","getItem","rowAbove","min","blocksOffset","round","getDifferenceFromInitialOffset","x","draggedChildDepth","abovePath","aboveNode","prevPath","prevParent","prevTreeIndex","nextPath","nextParent","nodeDragSourcePropInjection","connect","dragSource","dragPreview","nodeDropTargetPropInjection","dragged","dropTarget","el","_reactDnd","DragSource","nodeDragSource","DropTarget","nodeDropTarget","DragDropContext","_reactDndHtml5Backend2","_reactDndHtml5Backend","beginDrag","getDropResult","dropTargetNode","drop","hover","needsRedraw","fromIndex","toIndex","count","rowsWithoutMoved","locals","pointFade","arrow-pulse"],"mappings":"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","file":"react-sortable-tree.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"prop-types\"), require(\"react\"), require(\"lodash.isequal\"), require(\"react-dnd\"), require(\"react-dnd-html5-backend\"), require(\"react-dnd-scrollzone\"), require(\"react-virtualized\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"prop-types\", \"react\", \"lodash.isequal\", \"react-dnd\", \"react-dnd-html5-backend\", \"react-dnd-scrollzone\", \"react-virtualized\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactSortableTree\"] = factory(require(\"prop-types\"), require(\"react\"), require(\"lodash.isequal\"), require(\"react-dnd\"), require(\"react-dnd-html5-backend\"), require(\"react-dnd-scrollzone\"), require(\"react-virtualized\"));\n\telse\n\t\troot[\"ReactSortableTree\"] = factory(root[\"prop-types\"], root[\"react\"], root[\"lodash.isequal\"], root[\"react-dnd\"], root[\"react-dnd-html5-backend\"], root[\"react-dnd-scrollzone\"], root[\"react-virtualized\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_22__, __WEBPACK_EXTERNAL_MODULE_23__, __WEBPACK_EXTERNAL_MODULE_24__, __WEBPACK_EXTERNAL_MODULE_25__, __WEBPACK_EXTERNAL_MODULE_26__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"prop-types\"), require(\"react\"), require(\"lodash.isequal\"), require(\"react-dnd\"), require(\"react-dnd-html5-backend\"), require(\"react-dnd-scrollzone\"), require(\"react-virtualized\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"prop-types\", \"react\", \"lodash.isequal\", \"react-dnd\", \"react-dnd-html5-backend\", \"react-dnd-scrollzone\", \"react-virtualized\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactSortableTree\"] = factory(require(\"prop-types\"), require(\"react\"), require(\"lodash.isequal\"), require(\"react-dnd\"), require(\"react-dnd-html5-backend\"), require(\"react-dnd-scrollzone\"), require(\"react-virtualized\"));\n\telse\n\t\troot[\"ReactSortableTree\"] = factory(root[\"prop-types\"], root[\"react\"], root[\"lodash.isequal\"], root[\"react-dnd\"], root[\"react-dnd-html5-backend\"], root[\"react-dnd-scrollzone\"], root[\"react-virtualized\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_22__, __WEBPACK_EXTERNAL_MODULE_23__, __WEBPACK_EXTERNAL_MODULE_24__, __WEBPACK_EXTERNAL_MODULE_25__, __WEBPACK_EXTERNAL_MODULE_26__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.SortableTreeWithoutDndContext = undefined;\n\t\n\tvar _defaultHandlers = __webpack_require__(6);\n\t\n\tObject.keys(_defaultHandlers).forEach(function (key) {\n\t  if (key === \"default\" || key === \"__esModule\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _defaultHandlers[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _treeDataUtils = __webpack_require__(1);\n\t\n\tObject.keys(_treeDataUtils).forEach(function (key) {\n\t  if (key === \"default\" || key === \"__esModule\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _treeDataUtils[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _reactSortableTree = __webpack_require__(9);\n\t\n\tvar _reactSortableTree2 = _interopRequireDefault(_reactSortableTree);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = _reactSortableTree2.default;\n\t\n\t// Export the tree component without the react-dnd DragDropContext,\n\t// for when component is used with other components using react-dnd.\n\t// see: https://github.com/gaearon/react-dnd/issues/186\n\t\n\texports.SortableTreeWithoutDndContext = _reactSortableTree.SortableTreeWithoutDndContext;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\texports.getDescendantCount = getDescendantCount;\n\texports.getVisibleNodeCount = getVisibleNodeCount;\n\texports.getVisibleNodeInfoAtIndex = getVisibleNodeInfoAtIndex;\n\texports.walk = walk;\n\texports.map = map;\n\texports.toggleExpandedForAll = toggleExpandedForAll;\n\texports.changeNodeAtPath = changeNodeAtPath;\n\texports.removeNodeAtPath = removeNodeAtPath;\n\texports.getNodeAtPath = getNodeAtPath;\n\texports.addNodeUnderParent = addNodeUnderParent;\n\texports.insertNode = insertNode;\n\texports.getFlatDataFromTree = getFlatDataFromTree;\n\texports.getTreeFromFlatData = getTreeFromFlatData;\n\texports.isDescendant = isDescendant;\n\texports.getDepth = getDepth;\n\texports.find = find;\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\t/**\r\n\t * Performs a depth-first traversal over all of the node descendants,\r\n\t * incrementing currentIndex by 1 for each\r\n\t */\n\tfunction getNodeDataAtTreeIndexOrNextIndex(_ref) {\n\t    var targetIndex = _ref.targetIndex,\n\t        node = _ref.node,\n\t        currentIndex = _ref.currentIndex,\n\t        getNodeKey = _ref.getNodeKey,\n\t        _ref$path = _ref.path,\n\t        path = _ref$path === undefined ? [] : _ref$path,\n\t        _ref$lowerSiblingCoun = _ref.lowerSiblingCounts,\n\t        lowerSiblingCounts = _ref$lowerSiblingCoun === undefined ? [] : _ref$lowerSiblingCoun,\n\t        _ref$ignoreCollapsed = _ref.ignoreCollapsed,\n\t        ignoreCollapsed = _ref$ignoreCollapsed === undefined ? true : _ref$ignoreCollapsed,\n\t        _ref$isPseudoRoot = _ref.isPseudoRoot,\n\t        isPseudoRoot = _ref$isPseudoRoot === undefined ? false : _ref$isPseudoRoot;\n\t\n\t    // The pseudo-root is not considered in the path\n\t    var selfPath = !isPseudoRoot ? [].concat(_toConsumableArray(path), [getNodeKey({ node: node, treeIndex: currentIndex })]) : [];\n\t\n\t    // Return target node when found\n\t    if (currentIndex === targetIndex) {\n\t        return {\n\t            node: node,\n\t            lowerSiblingCounts: lowerSiblingCounts,\n\t            path: selfPath\n\t        };\n\t    }\n\t\n\t    // Add one and continue for nodes with no children or hidden children\n\t    if (!node.children || ignoreCollapsed && node.expanded !== true) {\n\t        return { nextIndex: currentIndex + 1 };\n\t    }\n\t\n\t    // Iterate over each child and their descendants and return the\n\t    // target node if childIndex reaches the targetIndex\n\t    var childIndex = currentIndex + 1;\n\t    var childCount = node.children.length;\n\t    for (var i = 0; i < childCount; i++) {\n\t        var result = getNodeDataAtTreeIndexOrNextIndex({\n\t            ignoreCollapsed: ignoreCollapsed,\n\t            getNodeKey: getNodeKey,\n\t            targetIndex: targetIndex,\n\t            node: node.children[i],\n\t            currentIndex: childIndex,\n\t            lowerSiblingCounts: [].concat(_toConsumableArray(lowerSiblingCounts), [childCount - i - 1]),\n\t            path: selfPath\n\t        });\n\t\n\t        if (result.node) {\n\t            return result;\n\t        }\n\t\n\t        childIndex = result.nextIndex;\n\t    }\n\t\n\t    // If the target node is not found, return the farthest traversed index\n\t    return { nextIndex: childIndex };\n\t}\n\t\n\tfunction getDescendantCount(_ref2) {\n\t    var node = _ref2.node,\n\t        _ref2$ignoreCollapsed = _ref2.ignoreCollapsed,\n\t        ignoreCollapsed = _ref2$ignoreCollapsed === undefined ? true : _ref2$ignoreCollapsed;\n\t\n\t    return getNodeDataAtTreeIndexOrNextIndex({\n\t        getNodeKey: function getNodeKey() {},\n\t        ignoreCollapsed: ignoreCollapsed,\n\t        node: node,\n\t        currentIndex: 0,\n\t        targetIndex: -1\n\t    }).nextIndex - 1;\n\t}\n\t\n\t/**\r\n\t * Walk all descendants of the given node, depth-first\r\n\t *\r\n\t * @param {Object} args - Function parameters\r\n\t * @param {function} args.callback - Function to call on each node\r\n\t * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\r\n\t * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n\t * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\r\n\t *                                        as the parent of all the nodes in the tree\r\n\t * @param {Object} args.node - A tree node\r\n\t * @param {Object=} args.parentNode - The parent node of `node`\r\n\t * @param {number} args.currentIndex - The treeIndex of `node`\r\n\t * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\r\n\t * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\r\n\t *                                             previous nodes in this path\r\n\t *\r\n\t * @return {number|false} nextIndex - Index of the next sibling of `node`,\r\n\t *                                    or false if the walk should be terminated\r\n\t */\n\tfunction walkDescendants(_ref3) {\n\t    var callback = _ref3.callback,\n\t        getNodeKey = _ref3.getNodeKey,\n\t        ignoreCollapsed = _ref3.ignoreCollapsed,\n\t        _ref3$isPseudoRoot = _ref3.isPseudoRoot,\n\t        isPseudoRoot = _ref3$isPseudoRoot === undefined ? false : _ref3$isPseudoRoot,\n\t        node = _ref3.node,\n\t        _ref3$parentNode = _ref3.parentNode,\n\t        parentNode = _ref3$parentNode === undefined ? null : _ref3$parentNode,\n\t        currentIndex = _ref3.currentIndex,\n\t        _ref3$path = _ref3.path,\n\t        path = _ref3$path === undefined ? [] : _ref3$path,\n\t        _ref3$lowerSiblingCou = _ref3.lowerSiblingCounts,\n\t        lowerSiblingCounts = _ref3$lowerSiblingCou === undefined ? [] : _ref3$lowerSiblingCou;\n\t\n\t    // The pseudo-root is not considered in the path\n\t    var selfPath = isPseudoRoot ? [] : [].concat(_toConsumableArray(path), [getNodeKey({ node: node, treeIndex: currentIndex })]);\n\t    var selfInfo = isPseudoRoot ? null : {\n\t        node: node,\n\t        parentNode: parentNode,\n\t        path: selfPath,\n\t        lowerSiblingCounts: lowerSiblingCounts,\n\t        treeIndex: currentIndex\n\t    };\n\t\n\t    if (!isPseudoRoot) {\n\t        var callbackResult = callback(selfInfo);\n\t\n\t        // Cut walk short if the callback returned false\n\t        if (callbackResult === false) {\n\t            return false;\n\t        }\n\t    }\n\t\n\t    // Return self on nodes with no children or hidden children\n\t    if (!node.children || node.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n\t        return currentIndex;\n\t    }\n\t\n\t    // Get all descendants\n\t    var childIndex = currentIndex;\n\t    var childCount = node.children.length;\n\t    if (typeof node.children !== 'function') {\n\t        for (var i = 0; i < childCount; i++) {\n\t            childIndex = walkDescendants({\n\t                callback: callback,\n\t                getNodeKey: getNodeKey,\n\t                ignoreCollapsed: ignoreCollapsed,\n\t                node: node.children[i],\n\t                parentNode: isPseudoRoot ? null : node,\n\t                currentIndex: childIndex + 1,\n\t                lowerSiblingCounts: [].concat(_toConsumableArray(lowerSiblingCounts), [childCount - i - 1]),\n\t                path: selfPath\n\t            });\n\t\n\t            // Cut walk short if the callback returned false\n\t            if (childIndex === false) {\n\t                return false;\n\t            }\n\t        }\n\t    }\n\t\n\t    return childIndex;\n\t}\n\t\n\t/**\r\n\t * Perform a change on the given node and all its descendants, traversing the tree depth-first\r\n\t *\r\n\t * @param {Object} args - Function parameters\r\n\t * @param {function} args.callback - Function to call on each node\r\n\t * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\r\n\t * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n\t * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\r\n\t *                                        as the parent of all the nodes in the tree\r\n\t * @param {Object} args.node - A tree node\r\n\t * @param {Object=} args.parentNode - The parent node of `node`\r\n\t * @param {number} args.currentIndex - The treeIndex of `node`\r\n\t * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\r\n\t * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\r\n\t *                                             previous nodes in this path\r\n\t *\r\n\t * @return {number|false} nextIndex - Index of the next sibling of `node`,\r\n\t *                                    or false if the walk should be terminated\r\n\t */\n\tfunction mapDescendants(_ref4) {\n\t    var callback = _ref4.callback,\n\t        getNodeKey = _ref4.getNodeKey,\n\t        ignoreCollapsed = _ref4.ignoreCollapsed,\n\t        _ref4$isPseudoRoot = _ref4.isPseudoRoot,\n\t        isPseudoRoot = _ref4$isPseudoRoot === undefined ? false : _ref4$isPseudoRoot,\n\t        node = _ref4.node,\n\t        _ref4$parentNode = _ref4.parentNode,\n\t        parentNode = _ref4$parentNode === undefined ? null : _ref4$parentNode,\n\t        currentIndex = _ref4.currentIndex,\n\t        _ref4$path = _ref4.path,\n\t        path = _ref4$path === undefined ? [] : _ref4$path,\n\t        _ref4$lowerSiblingCou = _ref4.lowerSiblingCounts,\n\t        lowerSiblingCounts = _ref4$lowerSiblingCou === undefined ? [] : _ref4$lowerSiblingCou;\n\t\n\t    var nextNode = _extends({}, node);\n\t\n\t    // The pseudo-root is not considered in the path\n\t    var selfPath = isPseudoRoot ? [] : [].concat(_toConsumableArray(path), [getNodeKey({ node: nextNode, treeIndex: currentIndex })]);\n\t    var selfInfo = {\n\t        node: nextNode,\n\t        parentNode: parentNode,\n\t        path: selfPath,\n\t        lowerSiblingCounts: lowerSiblingCounts,\n\t        treeIndex: currentIndex\n\t    };\n\t\n\t    // Return self on nodes with no children or hidden children\n\t    if (!nextNode.children || nextNode.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n\t        return {\n\t            treeIndex: currentIndex,\n\t            node: callback(selfInfo)\n\t        };\n\t    }\n\t\n\t    // Get all descendants\n\t    var childIndex = currentIndex;\n\t    var childCount = nextNode.children.length;\n\t    if (typeof nextNode.children !== 'function') {\n\t        nextNode.children = nextNode.children.map(function (child, i) {\n\t            var mapResult = mapDescendants({\n\t                callback: callback,\n\t                getNodeKey: getNodeKey,\n\t                ignoreCollapsed: ignoreCollapsed,\n\t                node: child,\n\t                parentNode: isPseudoRoot ? null : nextNode,\n\t                currentIndex: childIndex + 1,\n\t                lowerSiblingCounts: [].concat(_toConsumableArray(lowerSiblingCounts), [childCount - i - 1]),\n\t                path: selfPath\n\t            });\n\t            childIndex = mapResult.treeIndex;\n\t\n\t            return mapResult.node;\n\t        });\n\t    }\n\t\n\t    return {\n\t        node: callback(selfInfo),\n\t        treeIndex: childIndex\n\t    };\n\t}\n\t\n\t/**\r\n\t * Count all the visible (expanded) descendants in the tree data.\r\n\t *\r\n\t * @param {!Object[]} treeData - Tree data\r\n\t *\r\n\t * @return {number} count\r\n\t */\n\tfunction getVisibleNodeCount(_ref5) {\n\t    var treeData = _ref5.treeData;\n\t\n\t    var traverse = function traverse(node) {\n\t        if (!node.children || node.expanded !== true || typeof node.children === 'function') {\n\t            return 1;\n\t        }\n\t\n\t        return 1 + node.children.reduce(function (total, currentNode) {\n\t            return total + traverse(currentNode);\n\t        }, 0);\n\t    };\n\t\n\t    return treeData.reduce(function (total, currentNode) {\n\t        return total + traverse(currentNode);\n\t    }, 0);\n\t}\n\t\n\t/**\r\n\t * Get the <targetIndex>th visible node in the tree data.\r\n\t *\r\n\t * @param {!Object[]} treeData - Tree data\r\n\t * @param {!number} targetIndex - The index of the node to search for\r\n\t * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n\t *\r\n\t * @return {{\r\n\t *      node: Object,\r\n\t *      path: []string|[]number,\r\n\t *      lowerSiblingCounts: []number\r\n\t *  }|null} node - The node at targetIndex, or null if not found\r\n\t */\n\tfunction getVisibleNodeInfoAtIndex(_ref6) {\n\t    var treeData = _ref6.treeData,\n\t        targetIndex = _ref6.index,\n\t        getNodeKey = _ref6.getNodeKey;\n\t\n\t    if (!treeData || treeData.length < 1) {\n\t        return null;\n\t    }\n\t\n\t    // Call the tree traversal with a pseudo-root node\n\t    var result = getNodeDataAtTreeIndexOrNextIndex({\n\t        targetIndex: targetIndex,\n\t        getNodeKey: getNodeKey,\n\t        node: {\n\t            children: treeData,\n\t            expanded: true\n\t        },\n\t        currentIndex: -1,\n\t        path: [],\n\t        lowerSiblingCounts: [],\n\t        isPseudoRoot: true\n\t    });\n\t\n\t    if (result.node) {\n\t        return result;\n\t    }\n\t\n\t    return null;\n\t}\n\t\n\t/**\r\n\t * Walk descendants depth-first and call a callback on each\r\n\t *\r\n\t * @param {!Object[]} treeData - Tree data\r\n\t * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n\t * @param {function} callback - Function to call on each node\r\n\t * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n\t *\r\n\t * @return void\r\n\t */\n\tfunction walk(_ref7) {\n\t    var treeData = _ref7.treeData,\n\t        getNodeKey = _ref7.getNodeKey,\n\t        callback = _ref7.callback,\n\t        _ref7$ignoreCollapsed = _ref7.ignoreCollapsed,\n\t        ignoreCollapsed = _ref7$ignoreCollapsed === undefined ? true : _ref7$ignoreCollapsed;\n\t\n\t    if (!treeData || treeData.length < 1) {\n\t        return;\n\t    }\n\t\n\t    return walkDescendants({\n\t        callback: callback,\n\t        getNodeKey: getNodeKey,\n\t        ignoreCollapsed: ignoreCollapsed,\n\t        isPseudoRoot: true,\n\t        node: { children: treeData },\n\t        currentIndex: -1,\n\t        path: [],\n\t        lowerSiblingCounts: []\n\t    });\n\t}\n\t\n\t/**\r\n\t * Perform a depth-first transversal of the descendants and\r\n\t *  make a change to every node in the tree\r\n\t *\r\n\t * @param {!Object[]} treeData - Tree data\r\n\t * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n\t * @param {function} callback - Function to call on each node\r\n\t * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n\t *\r\n\t * @return {Object[]} changedTreeData - The changed tree data\r\n\t */\n\tfunction map(_ref8) {\n\t    var treeData = _ref8.treeData,\n\t        getNodeKey = _ref8.getNodeKey,\n\t        callback = _ref8.callback,\n\t        _ref8$ignoreCollapsed = _ref8.ignoreCollapsed,\n\t        ignoreCollapsed = _ref8$ignoreCollapsed === undefined ? true : _ref8$ignoreCollapsed;\n\t\n\t    if (!treeData || treeData.length < 1) {\n\t        return [];\n\t    }\n\t\n\t    return mapDescendants({\n\t        callback: callback,\n\t        getNodeKey: getNodeKey,\n\t        ignoreCollapsed: ignoreCollapsed,\n\t        isPseudoRoot: true,\n\t        node: { children: treeData },\n\t        currentIndex: -1,\n\t        path: [],\n\t        lowerSiblingCounts: []\n\t    }).node.children;\n\t}\n\t\n\t/**\r\n\t * Expand or close every node in the tree\r\n\t *\r\n\t * @param {!Object[]} treeData - Tree data\r\n\t * @param {?boolean} expanded - Whether the node is expanded or not\r\n\t *\r\n\t * @return {Object[]} changedTreeData - The changed tree data\r\n\t */\n\tfunction toggleExpandedForAll(_ref9) {\n\t    var treeData = _ref9.treeData,\n\t        _ref9$expanded = _ref9.expanded,\n\t        expanded = _ref9$expanded === undefined ? true : _ref9$expanded;\n\t\n\t    return map({\n\t        treeData: treeData,\n\t        callback: function callback(_ref10) {\n\t            var node = _ref10.node;\n\t            return _extends({}, node, { expanded: expanded });\n\t        },\n\t        getNodeKey: function getNodeKey(_ref11) {\n\t            var treeIndex = _ref11.treeIndex;\n\t            return treeIndex;\n\t        },\n\t        ignoreCollapsed: false\n\t    });\n\t}\n\t\n\t/**\r\n\t * Replaces node at path with object, or callback-defined object\r\n\t *\r\n\t * @param {!Object[]} treeData\r\n\t * @param {number[]|string[]} path - Array of keys leading up to node to be changed\r\n\t * @param {function|any} newNode - Node to replace the node at the path with, or a function producing the new node\r\n\t * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n\t * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n\t *\r\n\t * @return {Object[]} changedTreeData - The changed tree data\r\n\t */\n\tfunction changeNodeAtPath(_ref12) {\n\t    var treeData = _ref12.treeData,\n\t        path = _ref12.path,\n\t        newNode = _ref12.newNode,\n\t        getNodeKey = _ref12.getNodeKey,\n\t        _ref12$ignoreCollapse = _ref12.ignoreCollapsed,\n\t        ignoreCollapsed = _ref12$ignoreCollapse === undefined ? true : _ref12$ignoreCollapse;\n\t\n\t    var RESULT_MISS = 'RESULT_MISS';\n\t    var traverse = function traverse(_ref13) {\n\t        var _ref13$isPseudoRoot = _ref13.isPseudoRoot,\n\t            isPseudoRoot = _ref13$isPseudoRoot === undefined ? false : _ref13$isPseudoRoot,\n\t            node = _ref13.node,\n\t            currentTreeIndex = _ref13.currentTreeIndex,\n\t            pathIndex = _ref13.pathIndex;\n\t\n\t        if (!isPseudoRoot && getNodeKey({ node: node, treeIndex: currentTreeIndex }) !== path[pathIndex]) {\n\t            return RESULT_MISS;\n\t        }\n\t\n\t        if (pathIndex >= path.length - 1) {\n\t            // If this is the final location in the path, return its changed form\n\t            return typeof newNode === 'function' ? newNode({ node: node, treeIndex: currentTreeIndex }) : newNode;\n\t        } else if (!node.children) {\n\t            // If this node is part of the path, but has no children, return the unchanged node\n\t            throw new Error('Path referenced children of node with no children.');\n\t        }\n\t\n\t        var nextTreeIndex = currentTreeIndex + 1;\n\t        for (var i = 0; i < node.children.length; i++) {\n\t            var _result = traverse({\n\t                node: node.children[i],\n\t                currentTreeIndex: nextTreeIndex,\n\t                pathIndex: pathIndex + 1\n\t            });\n\t\n\t            // If the result went down the correct path\n\t            if (_result !== RESULT_MISS) {\n\t                if (_result) {\n\t                    // If the result was truthy (in this case, an object),\n\t                    //  pass it to the next level of recursion up\n\t                    return _extends({}, node, {\n\t                        children: [].concat(_toConsumableArray(node.children.slice(0, i)), [_result], _toConsumableArray(node.children.slice(i + 1)))\n\t                    });\n\t                }\n\t                // If the result was falsy (returned from the newNode function), then\n\t                //  delete the node from the array.\n\t                return _extends({}, node, {\n\t                    children: [].concat(_toConsumableArray(node.children.slice(0, i)), _toConsumableArray(node.children.slice(i + 1)))\n\t                });\n\t            }\n\t\n\t            nextTreeIndex += 1 + getDescendantCount({ node: node.children[i], ignoreCollapsed: ignoreCollapsed });\n\t        }\n\t\n\t        return RESULT_MISS;\n\t    };\n\t\n\t    // Use a pseudo-root node in the beginning traversal\n\t    var result = traverse({\n\t        node: { children: treeData },\n\t        currentTreeIndex: -1,\n\t        pathIndex: -1,\n\t        isPseudoRoot: true\n\t    });\n\t\n\t    if (result === RESULT_MISS) {\n\t        throw new Error('No node found at the given path.');\n\t    }\n\t\n\t    return result.children;\n\t}\n\t\n\t/**\r\n\t * Removes the node at the specified path and returns the resulting treeData.\r\n\t *\r\n\t * @param {!Object[]} treeData\r\n\t * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\r\n\t * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n\t * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n\t *\r\n\t * @return {Object[]} changedTreeData - The tree data with the node removed\r\n\t */\n\tfunction removeNodeAtPath(_ref14) {\n\t    var treeData = _ref14.treeData,\n\t        path = _ref14.path,\n\t        getNodeKey = _ref14.getNodeKey,\n\t        _ref14$ignoreCollapse = _ref14.ignoreCollapsed,\n\t        ignoreCollapsed = _ref14$ignoreCollapse === undefined ? true : _ref14$ignoreCollapse;\n\t\n\t    return changeNodeAtPath({\n\t        treeData: treeData,\n\t        path: path,\n\t        getNodeKey: getNodeKey,\n\t        ignoreCollapsed: ignoreCollapsed,\n\t        newNode: null });\n\t}\n\t\n\t/**\r\n\t * Gets the node at the specified path\r\n\t *\r\n\t * @param {!Object[]} treeData\r\n\t * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\r\n\t * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n\t * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n\t *\r\n\t * @return {Object|null} nodeInfo - The node info at the given path, or null if not found\r\n\t */\n\tfunction getNodeAtPath(_ref15) {\n\t    var treeData = _ref15.treeData,\n\t        path = _ref15.path,\n\t        getNodeKey = _ref15.getNodeKey,\n\t        _ref15$ignoreCollapse = _ref15.ignoreCollapsed,\n\t        ignoreCollapsed = _ref15$ignoreCollapse === undefined ? true : _ref15$ignoreCollapse;\n\t\n\t    var foundNodeInfo = null;\n\t\n\t    try {\n\t        changeNodeAtPath({\n\t            treeData: treeData,\n\t            path: path,\n\t            getNodeKey: getNodeKey,\n\t            ignoreCollapsed: ignoreCollapsed,\n\t            newNode: function newNode(_ref16) {\n\t                var node = _ref16.node,\n\t                    treeIndex = _ref16.treeIndex;\n\t\n\t                foundNodeInfo = { node: node, treeIndex: treeIndex };\n\t                return node;\n\t            }\n\t        });\n\t    } catch (err) {\n\t        // Ignore the error -- the null return will be explanation enough\n\t    }\n\t\n\t    return foundNodeInfo;\n\t}\n\t\n\t/**\r\n\t * Adds the node to the specified parent and returns the resulting treeData.\r\n\t *\r\n\t * @param {!Object[]} treeData\r\n\t * @param {!Object} newNode - The node to insert\r\n\t * @param {number|string} parentKey - The key of the to-be parentNode of the node\r\n\t * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n\t * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n\t * @param {boolean=} expandParent - If true, expands the parentNode specified by parentPath\r\n\t *\r\n\t * @return {Object} result\r\n\t * @return {Object[]} result.treeData - The updated tree data\r\n\t * @return {number} result.treeIndex - The tree index at which the node was inserted\r\n\t */\n\tfunction addNodeUnderParent(_ref17) {\n\t    var treeData = _ref17.treeData,\n\t        newNode = _ref17.newNode,\n\t        _ref17$parentKey = _ref17.parentKey,\n\t        parentKey = _ref17$parentKey === undefined ? null : _ref17$parentKey,\n\t        getNodeKey = _ref17.getNodeKey,\n\t        _ref17$ignoreCollapse = _ref17.ignoreCollapsed,\n\t        ignoreCollapsed = _ref17$ignoreCollapse === undefined ? true : _ref17$ignoreCollapse,\n\t        _ref17$expandParent = _ref17.expandParent,\n\t        expandParent = _ref17$expandParent === undefined ? false : _ref17$expandParent;\n\t\n\t    if (parentKey === null) {\n\t        return {\n\t            treeData: [].concat(_toConsumableArray(treeData || []), [newNode]),\n\t            treeIndex: (treeData || []).length\n\t        };\n\t    }\n\t\n\t    var insertedTreeIndex = null;\n\t    var hasBeenAdded = false;\n\t    var changedTreeData = map({\n\t        treeData: treeData,\n\t        getNodeKey: getNodeKey,\n\t        ignoreCollapsed: ignoreCollapsed,\n\t        callback: function callback(_ref18) {\n\t            var node = _ref18.node,\n\t                treeIndex = _ref18.treeIndex,\n\t                path = _ref18.path;\n\t\n\t            var key = path ? path[path.length - 1] : null;\n\t            // Return nodes that are not the parent as-is\n\t            if (hasBeenAdded || key !== parentKey) {\n\t                return node;\n\t            }\n\t            hasBeenAdded = true;\n\t\n\t            var parentNode = _extends({}, node);\n\t\n\t            if (expandParent) {\n\t                parentNode.expanded = true;\n\t            }\n\t\n\t            // If no children exist yet, just add the single newNode\n\t            if (!parentNode.children) {\n\t                insertedTreeIndex = treeIndex + 1;\n\t                return _extends({}, parentNode, {\n\t                    children: [newNode]\n\t                });\n\t            }\n\t\n\t            if (typeof parentNode.children === 'function') {\n\t                throw new Error('Cannot add to children defined by a function');\n\t            }\n\t\n\t            var nextTreeIndex = treeIndex + 1;\n\t            for (var i = 0; i < parentNode.children.length; i++) {\n\t                nextTreeIndex += 1 + getDescendantCount({ node: parentNode.children[i], ignoreCollapsed: ignoreCollapsed });\n\t            }\n\t\n\t            insertedTreeIndex = nextTreeIndex;\n\t\n\t            return _extends({}, parentNode, {\n\t                children: [].concat(_toConsumableArray(parentNode.children), [newNode])\n\t            });\n\t        }\n\t    });\n\t\n\t    if (!hasBeenAdded) {\n\t        throw new Error('No node found with the given key.');\n\t    }\n\t\n\t    return {\n\t        treeData: changedTreeData,\n\t        treeIndex: insertedTreeIndex\n\t    };\n\t}\n\t\n\tfunction addNodeAtDepthAndIndex(_ref19) {\n\t    var targetDepth = _ref19.targetDepth,\n\t        minimumTreeIndex = _ref19.minimumTreeIndex,\n\t        newNode = _ref19.newNode,\n\t        ignoreCollapsed = _ref19.ignoreCollapsed,\n\t        expandParent = _ref19.expandParent,\n\t        _ref19$isPseudoRoot = _ref19.isPseudoRoot,\n\t        isPseudoRoot = _ref19$isPseudoRoot === undefined ? false : _ref19$isPseudoRoot,\n\t        isLastChild = _ref19.isLastChild,\n\t        node = _ref19.node,\n\t        currentIndex = _ref19.currentIndex,\n\t        currentDepth = _ref19.currentDepth,\n\t        getNodeKey = _ref19.getNodeKey,\n\t        _ref19$path = _ref19.path,\n\t        path = _ref19$path === undefined ? [] : _ref19$path;\n\t\n\t    var selfPath = function selfPath(n) {\n\t        return isPseudoRoot ? [] : [].concat(_toConsumableArray(path), [getNodeKey({ node: n, treeIndex: currentIndex })]);\n\t    };\n\t\n\t    // If the current position is the only possible place to add, add it\n\t    if (currentIndex >= minimumTreeIndex - 1 || isLastChild && !(node.children && node.children.length)) {\n\t        if (typeof node.children === 'function') {\n\t            throw new Error('Cannot add to children defined by a function');\n\t        } else {\n\t            var extraNodeProps = expandParent ? { expanded: true } : {};\n\t            var _nextNode = _extends({}, node, extraNodeProps, {\n\t                children: node.children ? [newNode].concat(_toConsumableArray(node.children)) : [newNode]\n\t            });\n\t\n\t            return {\n\t                node: _nextNode,\n\t                nextIndex: currentIndex + 2,\n\t                insertedTreeIndex: currentIndex + 1,\n\t                parentPath: selfPath(_nextNode),\n\t                parentNode: isPseudoRoot ? null : _nextNode\n\t            };\n\t        }\n\t    }\n\t\n\t    // If this is the target depth for the insertion,\n\t    // i.e., where the newNode can be added to the current node's children\n\t    if (currentDepth >= targetDepth - 1) {\n\t        // Skip over nodes with no children or hidden children\n\t        if (!node.children || typeof node.children === 'function' || node.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n\t            return { node: node, nextIndex: currentIndex + 1 };\n\t        }\n\t\n\t        // Scan over the children to see if there's a place among them that fulfills\n\t        // the minimumTreeIndex requirement\n\t        var _childIndex = currentIndex + 1;\n\t        var _insertedTreeIndex = null;\n\t        var insertIndex = null;\n\t        for (var i = 0; i < node.children.length; i++) {\n\t            // If a valid location is found, mark it as the insertion location and\n\t            // break out of the loop\n\t            if (_childIndex >= minimumTreeIndex) {\n\t                _insertedTreeIndex = _childIndex;\n\t                insertIndex = i;\n\t                break;\n\t            }\n\t\n\t            // Increment the index by the child itself plus the number of descendants it has\n\t            _childIndex += 1 + getDescendantCount({ node: node.children[i], ignoreCollapsed: ignoreCollapsed });\n\t        }\n\t\n\t        // If no valid indices to add the node were found\n\t        if (insertIndex === null) {\n\t            // If the last position in this node's children is less than the minimum index\n\t            // and there are more children on the level of this node, return without insertion\n\t            if (_childIndex < minimumTreeIndex && !isLastChild) {\n\t                return { node: node, nextIndex: _childIndex };\n\t            }\n\t\n\t            // Use the last position in the children array to insert the newNode\n\t            _insertedTreeIndex = _childIndex;\n\t            insertIndex = node.children.length;\n\t        }\n\t\n\t        // Insert the newNode at the insertIndex\n\t        var _nextNode2 = _extends({}, node, {\n\t            children: [].concat(_toConsumableArray(node.children.slice(0, insertIndex)), [newNode], _toConsumableArray(node.children.slice(insertIndex)))\n\t        });\n\t\n\t        // Return node with successful insert result\n\t        return {\n\t            node: _nextNode2,\n\t            nextIndex: _childIndex,\n\t            insertedTreeIndex: _insertedTreeIndex,\n\t            parentPath: selfPath(_nextNode2),\n\t            parentNode: isPseudoRoot ? null : _nextNode2\n\t        };\n\t    }\n\t\n\t    // Skip over nodes with no children or hidden children\n\t    if (!node.children || typeof node.children === 'function' || node.expanded !== true && ignoreCollapsed && !isPseudoRoot) {\n\t        return { node: node, nextIndex: currentIndex + 1 };\n\t    }\n\t\n\t    // Get all descendants\n\t    var insertedTreeIndex = null;\n\t    var pathFragment = null;\n\t    var parentNode = null;\n\t    var childIndex = currentIndex + 1;\n\t    var newChildren = node.children;\n\t    if (typeof newChildren !== 'function') {\n\t        newChildren = newChildren.map(function (child, i) {\n\t            if (insertedTreeIndex !== null) {\n\t                return child;\n\t            }\n\t\n\t            var mapResult = addNodeAtDepthAndIndex({\n\t                targetDepth: targetDepth,\n\t                minimumTreeIndex: minimumTreeIndex,\n\t                newNode: newNode,\n\t                ignoreCollapsed: ignoreCollapsed,\n\t                expandParent: expandParent,\n\t                isLastChild: isLastChild && i === newChildren.length - 1,\n\t                node: child,\n\t                currentIndex: childIndex,\n\t                currentDepth: currentDepth + 1,\n\t                getNodeKey: getNodeKey,\n\t                path: [] });\n\t\n\t            if ('insertedTreeIndex' in mapResult) {\n\t                insertedTreeIndex = mapResult.insertedTreeIndex;\n\t                pathFragment = mapResult.parentPath;\n\t                parentNode = mapResult.parentNode;\n\t            }\n\t\n\t            childIndex = mapResult.nextIndex;\n\t\n\t            return mapResult.node;\n\t        });\n\t    }\n\t\n\t    var nextNode = _extends({}, node, { children: newChildren });\n\t    var result = {\n\t        node: nextNode,\n\t        nextIndex: childIndex\n\t    };\n\t\n\t    if (insertedTreeIndex !== null) {\n\t        result.insertedTreeIndex = insertedTreeIndex;\n\t        result.parentPath = [].concat(_toConsumableArray(selfPath(nextNode)), _toConsumableArray(pathFragment));\n\t        result.parentNode = parentNode;\n\t    }\n\t\n\t    return result;\n\t}\n\t\n\t/**\r\n\t * Insert a node into the tree at the given depth, after the minimum index\r\n\t *\r\n\t * @param {!Object[]} treeData - Tree data\r\n\t * @param {!number} depth - The depth to insert the node at (the first level of the array being depth 0)\r\n\t * @param {!number} minimumTreeIndex - The lowest possible treeIndex to insert the node at\r\n\t * @param {!Object} newNode - The node to insert into the tree\r\n\t * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n\t * @param {boolean=} expandParent - If true, expands the parent of the inserted node\r\n\t * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n\t *\r\n\t * @return {Object} result\r\n\t * @return {Object[]} result.treeData - The tree data with the node added\r\n\t * @return {number} result.treeIndex - The tree index at which the node was inserted\r\n\t * @return {number[]|string[]} result.path - Array of keys leading to the node location after insertion\r\n\t * @return {Object} result.parentNode - The parent node of the inserted node\r\n\t */\n\tfunction insertNode(_ref20) {\n\t    var treeData = _ref20.treeData,\n\t        targetDepth = _ref20.depth,\n\t        minimumTreeIndex = _ref20.minimumTreeIndex,\n\t        newNode = _ref20.newNode,\n\t        _ref20$getNodeKey = _ref20.getNodeKey,\n\t        getNodeKey = _ref20$getNodeKey === undefined ? function () {} : _ref20$getNodeKey,\n\t        _ref20$ignoreCollapse = _ref20.ignoreCollapsed,\n\t        ignoreCollapsed = _ref20$ignoreCollapse === undefined ? true : _ref20$ignoreCollapse,\n\t        _ref20$expandParent = _ref20.expandParent,\n\t        expandParent = _ref20$expandParent === undefined ? false : _ref20$expandParent;\n\t\n\t    if (!treeData && targetDepth === 0) {\n\t        return {\n\t            treeData: [newNode],\n\t            treeIndex: 0,\n\t            path: [getNodeKey({ node: newNode, treeIndex: 0 })],\n\t            parentNode: null\n\t        };\n\t    }\n\t\n\t    var insertResult = addNodeAtDepthAndIndex({\n\t        targetDepth: targetDepth,\n\t        minimumTreeIndex: minimumTreeIndex,\n\t        newNode: newNode,\n\t        ignoreCollapsed: ignoreCollapsed,\n\t        expandParent: expandParent,\n\t        getNodeKey: getNodeKey,\n\t        isPseudoRoot: true,\n\t        isLastChild: true,\n\t        node: { children: treeData },\n\t        currentIndex: -1,\n\t        currentDepth: -1\n\t    });\n\t\n\t    if (!('insertedTreeIndex' in insertResult)) {\n\t        throw new Error('No suitable position found to insert.');\n\t    }\n\t\n\t    var treeIndex = insertResult.insertedTreeIndex;\n\t    return {\n\t        treeData: insertResult.node.children,\n\t        treeIndex: treeIndex,\n\t        path: [].concat(_toConsumableArray(insertResult.parentPath), [getNodeKey({ node: newNode, treeIndex: treeIndex })]),\n\t        parentNode: insertResult.parentNode\n\t    };\n\t}\n\t\n\t/**\r\n\t * Get tree data flattened.\r\n\t *\r\n\t * @param {!Object[]} treeData - Tree data\r\n\t * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n\t * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n\t *\r\n\t * @return {{\r\n\t *      node: Object,\r\n\t *      path: []string|[]number,\r\n\t *      lowerSiblingCounts: []number\r\n\t *  }}[] nodes - The node array\r\n\t */\n\tfunction getFlatDataFromTree(_ref21) {\n\t    var treeData = _ref21.treeData,\n\t        getNodeKey = _ref21.getNodeKey,\n\t        _ref21$ignoreCollapse = _ref21.ignoreCollapsed,\n\t        ignoreCollapsed = _ref21$ignoreCollapse === undefined ? true : _ref21$ignoreCollapse;\n\t\n\t    if (!treeData || treeData.length < 1) {\n\t        return [];\n\t    }\n\t\n\t    var flattened = [];\n\t    walk({\n\t        treeData: treeData,\n\t        getNodeKey: getNodeKey,\n\t        ignoreCollapsed: ignoreCollapsed,\n\t        callback: function callback(nodeInfo) {\n\t            flattened.push(nodeInfo);\n\t        }\n\t    });\n\t\n\t    return flattened;\n\t}\n\t\n\t/**\r\n\t * Generate a tree structure from flat data.\r\n\t *\r\n\t * @param {!Object[]} flatData\r\n\t * @param {!function=} getKey - Function to get the key from the nodeData\r\n\t * @param {!function=} getParentKey - Function to get the parent key from the nodeData\r\n\t * @param {string|number=} rootKey - The value returned by `getParentKey` that corresponds to the root node.\r\n\t *                                  For example, if your nodes have id 1-99, you might use rootKey = 0\r\n\t *\r\n\t * @return {Object[]} treeData - The flat data represented as a tree\r\n\t */\n\tfunction getTreeFromFlatData(_ref22) {\n\t    var flatData = _ref22.flatData,\n\t        _ref22$getKey = _ref22.getKey,\n\t        getKey = _ref22$getKey === undefined ? function (node) {\n\t        return node.id;\n\t    } : _ref22$getKey,\n\t        _ref22$getParentKey = _ref22.getParentKey,\n\t        getParentKey = _ref22$getParentKey === undefined ? function (node) {\n\t        return node.parentId;\n\t    } : _ref22$getParentKey,\n\t        _ref22$rootKey = _ref22.rootKey,\n\t        rootKey = _ref22$rootKey === undefined ? '0' : _ref22$rootKey;\n\t\n\t    if (!flatData) {\n\t        return [];\n\t    }\n\t\n\t    var childrenToParents = {};\n\t    flatData.forEach(function (child) {\n\t        var parentKey = getParentKey(child);\n\t\n\t        if (parentKey in childrenToParents) {\n\t            childrenToParents[parentKey].push(child);\n\t        } else {\n\t            childrenToParents[parentKey] = [child];\n\t        }\n\t    });\n\t\n\t    if (!(rootKey in childrenToParents)) {\n\t        return [];\n\t    }\n\t\n\t    var trav = function trav(parent) {\n\t        var parentKey = getKey(parent);\n\t        if (parentKey in childrenToParents) {\n\t            return _extends({}, parent, {\n\t                children: childrenToParents[parentKey].map(function (child) {\n\t                    return trav(child);\n\t                })\n\t            });\n\t        }\n\t\n\t        return _extends({}, parent);\n\t    };\n\t\n\t    return childrenToParents[rootKey].map(function (child) {\n\t        return trav(child);\n\t    });\n\t}\n\t\n\t/**\r\n\t * Check if a node is a descendant of another node.\r\n\t *\r\n\t * @param {!Object} older - Potential ancestor of younger node\r\n\t * @param {!Object} younger - Potential descendant of older node\r\n\t *\r\n\t * @return {boolean}\r\n\t */\n\tfunction isDescendant(older, younger) {\n\t    return !!older.children && typeof older.children !== 'function' && older.children.some(function (child) {\n\t        return child === younger || isDescendant(child, younger);\n\t    });\n\t}\n\t\n\t/**\r\n\t * Get the maximum depth of the children (the depth of the root node is 0).\r\n\t *\r\n\t * @param {!Object} node - Node in the tree\r\n\t * @param {?number} depth - The current depth\r\n\t *\r\n\t * @return {number} maxDepth - The deepest depth in the tree\r\n\t */\n\tfunction getDepth(node) {\n\t    var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t\n\t    if (!node.children) {\n\t        return depth;\n\t    }\n\t\n\t    if (typeof node.children === 'function') {\n\t        return depth + 1;\n\t    }\n\t\n\t    return node.children.reduce(function (deepest, child) {\n\t        return Math.max(deepest, getDepth(child, depth + 1));\n\t    }, depth);\n\t}\n\t\n\t/**\r\n\t * Find nodes matching a search query in the tree,\r\n\t *\r\n\t * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n\t * @param {!Object[]} treeData - Tree data\r\n\t * @param {?string|number} searchQuery - Function returning a boolean to indicate whether the node is a match or not\r\n\t * @param {!function} searchMethod - Function returning a boolean to indicate whether the node is a match or not\r\n\t * @param {?number} searchFocusOffset - The offset of the match to focus on\r\n\t *                                      (e.g., 0 focuses on the first match, 1 on the second)\r\n\t * @param {boolean=} expandAllMatchPaths - If true, expands the paths to any matched node\r\n\t * @param {boolean=} expandFocusMatchPaths - If true, expands the path to the focused node\r\n\t *\r\n\t * @return {Object[]} matches - An array of objects containing the matching `node`s, their `path`s and `treeIndex`s\r\n\t * @return {Object[]} treeData - The original tree data with all relevant nodes expanded.\r\n\t *                               If expandAllMatchPaths and expandFocusMatchPaths are both false,\r\n\t *                               it will be the same as the original tree data.\r\n\t */\n\tfunction find(_ref23) {\n\t    var getNodeKey = _ref23.getNodeKey,\n\t        treeData = _ref23.treeData,\n\t        searchQuery = _ref23.searchQuery,\n\t        searchMethod = _ref23.searchMethod,\n\t        searchFocusOffset = _ref23.searchFocusOffset,\n\t        _ref23$expandAllMatch = _ref23.expandAllMatchPaths,\n\t        expandAllMatchPaths = _ref23$expandAllMatch === undefined ? false : _ref23$expandAllMatch,\n\t        _ref23$expandFocusMat = _ref23.expandFocusMatchPaths,\n\t        expandFocusMatchPaths = _ref23$expandFocusMat === undefined ? true : _ref23$expandFocusMat;\n\t\n\t    var matchCount = 0;\n\t    var trav = function trav(_ref24) {\n\t        var _ref24$isPseudoRoot = _ref24.isPseudoRoot,\n\t            isPseudoRoot = _ref24$isPseudoRoot === undefined ? false : _ref24$isPseudoRoot,\n\t            node = _ref24.node,\n\t            currentIndex = _ref24.currentIndex,\n\t            _ref24$path = _ref24.path,\n\t            path = _ref24$path === undefined ? [] : _ref24$path;\n\t\n\t        var matches = [];\n\t        var isSelfMatch = false;\n\t        var hasFocusMatch = false;\n\t        // The pseudo-root is not considered in the path\n\t        var selfPath = isPseudoRoot ? [] : [].concat(_toConsumableArray(path), [getNodeKey({ node: node, treeIndex: currentIndex })]);\n\t        var extraInfo = isPseudoRoot ? null : {\n\t            path: selfPath,\n\t            treeIndex: currentIndex\n\t        };\n\t\n\t        // Nodes with with children that aren't lazy\n\t        var hasChildren = node.children && typeof node.children !== 'function' && node.children.length > 0;\n\t\n\t        // Examine the current node to see if it is a match\n\t        if (!isPseudoRoot && searchMethod(_extends({}, extraInfo, { node: node, searchQuery: searchQuery }))) {\n\t            if (matchCount === searchFocusOffset) {\n\t                hasFocusMatch = true;\n\t            }\n\t\n\t            // Keep track of the number of matching nodes, so we know when the searchFocusOffset\n\t            //  is reached\n\t            matchCount++;\n\t\n\t            // We cannot add this node to the matches right away, as it may be changed\n\t            //  during the search of the descendants. The entire node is used in\n\t            //  comparisons between nodes inside the `matches` and `treeData` results\n\t            //  of this method (`find`)\n\t            isSelfMatch = true;\n\t        }\n\t\n\t        var childIndex = currentIndex;\n\t        var newNode = _extends({}, node);\n\t        if (hasChildren) {\n\t            // Get all descendants\n\t            newNode.children = newNode.children.map(function (child) {\n\t                var mapResult = trav({\n\t                    node: child,\n\t                    currentIndex: childIndex + 1,\n\t                    path: selfPath\n\t                });\n\t\n\t                // Ignore hidden nodes by only advancing the index counter to the returned treeIndex\n\t                // if the child is expanded.\n\t                //\n\t                // The child could have been expanded from the start,\n\t                // or expanded due to a matching node being found in its descendants\n\t                if (mapResult.node.expanded) {\n\t                    childIndex = mapResult.treeIndex;\n\t                } else {\n\t                    childIndex += 1;\n\t                }\n\t\n\t                if (mapResult.matches.length > 0 || mapResult.hasFocusMatch) {\n\t                    matches = [].concat(_toConsumableArray(matches), _toConsumableArray(mapResult.matches));\n\t                    if (mapResult.hasFocusMatch) {\n\t                        hasFocusMatch = true;\n\t                    }\n\t\n\t                    // Expand the current node if it has descendants matching the search\n\t                    // and the settings are set to do so.\n\t                    if (expandAllMatchPaths && mapResult.matches.length > 0 || (expandAllMatchPaths || expandFocusMatchPaths) && mapResult.hasFocusMatch) {\n\t                        newNode.expanded = true;\n\t                    }\n\t                }\n\t\n\t                return mapResult.node;\n\t            });\n\t        }\n\t\n\t        // Cannot assign a treeIndex to hidden nodes\n\t        if (!isPseudoRoot && !newNode.expanded) {\n\t            matches = matches.map(function (match) {\n\t                return _extends({}, match, {\n\t                    treeIndex: null\n\t                });\n\t            });\n\t        }\n\t\n\t        // Add this node to the matches if it fits the search criteria.\n\t        // This is performed at the last minute so newNode can be sent in its final form.\n\t        if (isSelfMatch) {\n\t            matches = [_extends({}, extraInfo, { node: newNode })].concat(_toConsumableArray(matches));\n\t        }\n\t\n\t        return {\n\t            node: matches.length > 0 ? newNode : node,\n\t            matches: matches,\n\t            hasFocusMatch: hasFocusMatch,\n\t            treeIndex: childIndex\n\t        };\n\t    };\n\t\n\t    var result = trav({\n\t        node: { children: treeData },\n\t        isPseudoRoot: true,\n\t        currentIndex: -1\n\t    });\n\t\n\t    return {\n\t        matches: result.matches,\n\t        treeData: result.node.children\n\t    };\n\t}\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n\t/*\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\n\t\tAuthor Tobias Koppers @sokra\n\t*/\n\t// css base code, injected by the css-loader\n\tmodule.exports = function(useSourceMap) {\n\t\tvar list = [];\n\t\n\t\t// return the list of modules as css string\n\t\tlist.toString = function toString() {\n\t\t\treturn this.map(function (item) {\n\t\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\t\tif(item[2]) {\n\t\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t\t} else {\n\t\t\t\t\treturn content;\n\t\t\t\t}\n\t\t\t}).join(\"\");\n\t\t};\n\t\n\t\t// import a list of modules into the list\n\t\tlist.i = function(modules, mediaQuery) {\n\t\t\tif(typeof modules === \"string\")\n\t\t\t\tmodules = [[null, modules, \"\"]];\n\t\t\tvar alreadyImportedModules = {};\n\t\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\t\tvar id = this[i][0];\n\t\t\t\tif(typeof id === \"number\")\n\t\t\t\t\talreadyImportedModules[id] = true;\n\t\t\t}\n\t\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\t\tvar item = modules[i];\n\t\t\t\t// skip already imported module\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t\t}\n\t\t\t\t\tlist.push(item);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn list;\n\t};\n\t\n\tfunction cssWithMappingToString(item, useSourceMap) {\n\t\tvar content = item[1] || '';\n\t\tvar cssMapping = item[3];\n\t\tif (!cssMapping) {\n\t\t\treturn content;\n\t\t}\n\t\n\t\tif (useSourceMap && typeof btoa === 'function') {\n\t\t\tvar sourceMapping = toComment(cssMapping);\n\t\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t\t});\n\t\n\t\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t\t}\n\t\n\t\treturn [content].join('\\n');\n\t}\n\t\n\t// Adapted from convert-source-map (MIT)\n\tfunction toComment(sourceMap) {\n\t\t// eslint-disable-next-line no-undef\n\t\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\t\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\t\n\t\treturn '/*# ' + data + ' */';\n\t}\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\n\t\tAuthor Tobias Koppers @sokra\n\t*/\n\tvar stylesInDom = {},\n\t\tmemoize = function(fn) {\n\t\t\tvar memo;\n\t\t\treturn function () {\n\t\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\t\treturn memo;\n\t\t\t};\n\t\t},\n\t\tisOldIE = memoize(function() {\n\t\t\treturn /msie [6-9]\\b/.test(self.navigator.userAgent.toLowerCase());\n\t\t}),\n\t\tgetHeadElement = memoize(function () {\n\t\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t\t}),\n\t\tsingletonElement = null,\n\t\tsingletonCounter = 0,\n\t\tstyleElementsInsertedAtTop = [];\n\t\n\tmodule.exports = function(list, options) {\n\t\tif(false) {\n\t\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t\t}\n\t\n\t\toptions = options || {};\n\t\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t\t// tags it will allow on a page\n\t\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\t\n\t\t// By default, add <style> tags to the bottom of <head>.\n\t\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\t\n\t\tvar styles = listToStyles(list);\n\t\taddStylesToDom(styles, options);\n\t\n\t\treturn function update(newList) {\n\t\t\tvar mayRemove = [];\n\t\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\t\tvar item = styles[i];\n\t\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\t\tdomStyle.refs--;\n\t\t\t\tmayRemove.push(domStyle);\n\t\t\t}\n\t\t\tif(newList) {\n\t\t\t\tvar newStyles = listToStyles(newList);\n\t\t\t\taddStylesToDom(newStyles, options);\n\t\t\t}\n\t\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\t\tvar domStyle = mayRemove[i];\n\t\t\t\tif(domStyle.refs === 0) {\n\t\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\t\n\tfunction addStylesToDom(styles, options) {\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tif(domStyle) {\n\t\t\t\tdomStyle.refs++;\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t\t}\n\t\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar parts = [];\n\t\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t\t}\n\t\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction listToStyles(list) {\n\t\tvar styles = [];\n\t\tvar newStyles = {};\n\t\tfor(var i = 0; i < list.length; i++) {\n\t\t\tvar item = list[i];\n\t\t\tvar id = item[0];\n\t\t\tvar css = item[1];\n\t\t\tvar media = item[2];\n\t\t\tvar sourceMap = item[3];\n\t\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\t\tif(!newStyles[id])\n\t\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\t\telse\n\t\t\t\tnewStyles[id].parts.push(part);\n\t\t}\n\t\treturn styles;\n\t}\n\t\n\tfunction insertStyleElement(options, styleElement) {\n\t\tvar head = getHeadElement();\n\t\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\t\tif (options.insertAt === \"top\") {\n\t\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t\t} else {\n\t\t\t\thead.appendChild(styleElement);\n\t\t\t}\n\t\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t\t} else if (options.insertAt === \"bottom\") {\n\t\t\thead.appendChild(styleElement);\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t\t}\n\t}\n\t\n\tfunction removeStyleElement(styleElement) {\n\t\tstyleElement.parentNode.removeChild(styleElement);\n\t\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\t\tif(idx >= 0) {\n\t\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t\t}\n\t}\n\t\n\tfunction createStyleElement(options) {\n\t\tvar styleElement = document.createElement(\"style\");\n\t\tstyleElement.type = \"text/css\";\n\t\tinsertStyleElement(options, styleElement);\n\t\treturn styleElement;\n\t}\n\t\n\tfunction createLinkElement(options) {\n\t\tvar linkElement = document.createElement(\"link\");\n\t\tlinkElement.rel = \"stylesheet\";\n\t\tinsertStyleElement(options, linkElement);\n\t\treturn linkElement;\n\t}\n\t\n\tfunction addStyle(obj, options) {\n\t\tvar styleElement, update, remove;\n\t\n\t\tif (options.singleton) {\n\t\t\tvar styleIndex = singletonCounter++;\n\t\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t\t} else if(obj.sourceMap &&\n\t\t\ttypeof URL === \"function\" &&\n\t\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\t\ttypeof Blob === \"function\" &&\n\t\t\ttypeof btoa === \"function\") {\n\t\t\tstyleElement = createLinkElement(options);\n\t\t\tupdate = updateLink.bind(null, styleElement);\n\t\t\tremove = function() {\n\t\t\t\tremoveStyleElement(styleElement);\n\t\t\t\tif(styleElement.href)\n\t\t\t\t\tURL.revokeObjectURL(styleElement.href);\n\t\t\t};\n\t\t} else {\n\t\t\tstyleElement = createStyleElement(options);\n\t\t\tupdate = applyToTag.bind(null, styleElement);\n\t\t\tremove = function() {\n\t\t\t\tremoveStyleElement(styleElement);\n\t\t\t};\n\t\t}\n\t\n\t\tupdate(obj);\n\t\n\t\treturn function updateStyle(newObj) {\n\t\t\tif(newObj) {\n\t\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\t\treturn;\n\t\t\t\tupdate(obj = newObj);\n\t\t\t} else {\n\t\t\t\tremove();\n\t\t\t}\n\t\t};\n\t}\n\t\n\tvar replaceText = (function () {\n\t\tvar textStore = [];\n\t\n\t\treturn function (index, replacement) {\n\t\t\ttextStore[index] = replacement;\n\t\t\treturn textStore.filter(Boolean).join('\\n');\n\t\t};\n\t})();\n\t\n\tfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\t\tvar css = remove ? \"\" : obj.css;\n\t\n\t\tif (styleElement.styleSheet) {\n\t\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t\t} else {\n\t\t\tvar cssNode = document.createTextNode(css);\n\t\t\tvar childNodes = styleElement.childNodes;\n\t\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\t\tif (childNodes.length) {\n\t\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t\t} else {\n\t\t\t\tstyleElement.appendChild(cssNode);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction applyToTag(styleElement, obj) {\n\t\tvar css = obj.css;\n\t\tvar media = obj.media;\n\t\n\t\tif(media) {\n\t\t\tstyleElement.setAttribute(\"media\", media)\n\t\t}\n\t\n\t\tif(styleElement.styleSheet) {\n\t\t\tstyleElement.styleSheet.cssText = css;\n\t\t} else {\n\t\t\twhile(styleElement.firstChild) {\n\t\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t\t}\n\t\t\tstyleElement.appendChild(document.createTextNode(css));\n\t\t}\n\t}\n\t\n\tfunction updateLink(linkElement, obj) {\n\t\tvar css = obj.css;\n\t\tvar sourceMap = obj.sourceMap;\n\t\n\t\tif(sourceMap) {\n\t\t\t// http://stackoverflow.com/a/26603875\n\t\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t\t}\n\t\n\t\tvar blob = new Blob([css], { type: \"text/css\" });\n\t\n\t\tvar oldSrc = linkElement.href;\n\t\n\t\tlinkElement.href = URL.createObjectURL(blob);\n\t\n\t\tif(oldSrc)\n\t\t\tURL.revokeObjectURL(oldSrc);\n\t}\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\texports.defaultGetNodeKey = defaultGetNodeKey;\n\texports.defaultSearchMethod = defaultSearchMethod;\n\tfunction defaultGetNodeKey(_ref) {\n\t    var _node = _ref.node,\n\t        treeIndex = _ref.treeIndex;\n\t\n\t    return treeIndex;\n\t}\n\t\n\t// Cheap hack to get the text of a react object\n\tfunction getReactElementText(parent) {\n\t    if (typeof parent === 'string') {\n\t        return parent;\n\t    }\n\t\n\t    if ((typeof parent === 'undefined' ? 'undefined' : _typeof(parent)) !== 'object' || !parent.props || !parent.props.children || typeof parent.props.children !== 'string' && _typeof(parent.props.children) !== 'object') {\n\t        return '';\n\t    }\n\t\n\t    if (typeof parent.props.children === 'string') {\n\t        return parent.props.children;\n\t    }\n\t\n\t    return parent.props.children.map(function (child) {\n\t        return getReactElementText(child);\n\t    }).join('');\n\t}\n\t\n\t// Search for a query string inside a node property\n\tfunction stringSearch(key, searchQuery, node, path, treeIndex) {\n\t    if (typeof node[key] === 'function') {\n\t        return String(node[key]({ node: node, path: path, treeIndex: treeIndex })).indexOf(searchQuery) > -1;\n\t    } else if (_typeof(node[key]) === 'object') {\n\t        return getReactElementText(node[key]).indexOf(searchQuery) > -1;\n\t    }\n\t\n\t    return node[key] && String(node[key]).indexOf(searchQuery) > -1;\n\t}\n\t\n\tfunction defaultSearchMethod(_ref2) {\n\t    var node = _ref2.node,\n\t        path = _ref2.path,\n\t        treeIndex = _ref2.treeIndex,\n\t        searchQuery = _ref2.searchQuery;\n\t\n\t    return stringSearch('title', searchQuery, node, path, treeIndex) || stringSearch('subtitle', searchQuery, node, path, treeIndex);\n\t}\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.memoizedInsertNode = memoizedInsertNode;\n\t\n\tvar _treeDataUtils = __webpack_require__(1);\n\t\n\tvar memoizedInsertArgsArray = [];\n\tvar memoizedInsertKeysArray = [];\n\tvar memoizedInsertResult = null;\n\t\n\t/**\r\n\t * Insert a node into the tree at the given depth, after the minimum index\r\n\t *\r\n\t * @param {!Object[]} treeData - Tree data\r\n\t * @param {!number} depth - The depth to insert the node at (the first level of the array being depth 0)\r\n\t * @param {!number} minimumTreeIndex - The lowest possible treeIndex to insert the node at\r\n\t * @param {!Object} newNode - The node to insert into the tree\r\n\t * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n\t * @param {boolean=} expandParent - If true, expands the parent of the inserted node\r\n\t * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n\t *\r\n\t * @return {Object} result\r\n\t * @return {Object[]} result.treeData - The tree data with the node added\r\n\t * @return {number} result.treeIndex - The tree index at which the node was inserted\r\n\t * @return {number[]|string[]} result.path - Array of keys leading to the node location after insertion\r\n\t */\n\tfunction memoizedInsertNode(args) {\n\t    var keysArray = Object.keys(args).sort();\n\t    var argsArray = keysArray.map(function (key) {\n\t        return args[key];\n\t    });\n\t\n\t    // If the arguments for the last insert operation are different than this time,\n\t    // recalculate the result\n\t    if (argsArray.length !== memoizedInsertArgsArray.length || argsArray.some(function (arg, index) {\n\t        return arg !== memoizedInsertArgsArray[index];\n\t    }) || keysArray.some(function (key, index) {\n\t        return key !== memoizedInsertKeysArray[index];\n\t    })) {\n\t        memoizedInsertArgsArray = argsArray;\n\t        memoizedInsertKeysArray = keysArray;\n\t        memoizedInsertResult = (0, _treeDataUtils.insertNode)(args);\n\t    }\n\t\n\t    return memoizedInsertResult;\n\t}\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _react = __webpack_require__(5);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _propTypes = __webpack_require__(4);\n\t\n\tvar _propTypes2 = _interopRequireDefault(_propTypes);\n\t\n\tvar _browserUtils = __webpack_require__(11);\n\t\n\tvar _nodeRendererDefault = __webpack_require__(19);\n\t\n\tvar _nodeRendererDefault2 = _interopRequireDefault(_nodeRendererDefault);\n\t\n\tvar _treeDataUtils = __webpack_require__(1);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar styles = _nodeRendererDefault2.default;\n\t// Add extra classes in browsers that don't support flex\n\tif (_browserUtils.getIEVersion < 10) {\n\t    styles = _extends({}, _nodeRendererDefault2.default, {\n\t        row: styles.row + ' ' + styles.row_NoFlex,\n\t        rowContents: styles.rowContents + ' ' + styles.rowContents_NoFlex,\n\t        rowLabel: styles.rowLabel + ' ' + styles.rowLabel_NoFlex,\n\t        rowToolbar: styles.rowToolbar + ' ' + styles.rowToolbar_NoFlex\n\t    });\n\t}\n\t\n\tvar NodeRendererDefault = function (_Component) {\n\t    _inherits(NodeRendererDefault, _Component);\n\t\n\t    function NodeRendererDefault() {\n\t        _classCallCheck(this, NodeRendererDefault);\n\t\n\t        return _possibleConstructorReturn(this, (NodeRendererDefault.__proto__ || Object.getPrototypeOf(NodeRendererDefault)).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(NodeRendererDefault, [{\n\t        key: 'render',\n\t        value: function render() {\n\t            var _props = this.props,\n\t                scaffoldBlockPxWidth = _props.scaffoldBlockPxWidth,\n\t                toggleChildrenVisibility = _props.toggleChildrenVisibility,\n\t                connectDragPreview = _props.connectDragPreview,\n\t                connectDragSource = _props.connectDragSource,\n\t                isDragging = _props.isDragging,\n\t                canDrop = _props.canDrop,\n\t                canDrag = _props.canDrag,\n\t                node = _props.node,\n\t                draggedNode = _props.draggedNode,\n\t                path = _props.path,\n\t                treeIndex = _props.treeIndex,\n\t                isSearchMatch = _props.isSearchMatch,\n\t                isSearchFocus = _props.isSearchFocus,\n\t                buttons = _props.buttons,\n\t                className = _props.className,\n\t                _props$style = _props.style,\n\t                style = _props$style === undefined ? {} : _props$style,\n\t                didDrop = _props.didDrop,\n\t                _isOver = _props.isOver,\n\t                _parentNode = _props.parentNode,\n\t                _endDrag = _props.endDrag,\n\t                _startDrag = _props.startDrag,\n\t                otherProps = _objectWithoutProperties(_props, ['scaffoldBlockPxWidth', 'toggleChildrenVisibility', 'connectDragPreview', 'connectDragSource', 'isDragging', 'canDrop', 'canDrag', 'node', 'draggedNode', 'path', 'treeIndex', 'isSearchMatch', 'isSearchFocus', 'buttons', 'className', 'style', 'didDrop', 'isOver', 'parentNode', 'endDrag', 'startDrag']);\n\t\n\t            var handle = void 0;\n\t            if (canDrag) {\n\t                if (typeof node.children === 'function' && node.expanded) {\n\t                    // Show a loading symbol on the handle when the children are expanded\n\t                    //  and yet still defined by a function (a callback to fetch the children)\n\t                    handle = _react2.default.createElement(\n\t                        'div',\n\t                        { className: styles.loadingHandle },\n\t                        _react2.default.createElement(\n\t                            'div',\n\t                            { className: styles.loadingCircle },\n\t                            _react2.default.createElement('div', { className: styles.loadingCirclePoint }),\n\t                            _react2.default.createElement('div', { className: styles.loadingCirclePoint }),\n\t                            _react2.default.createElement('div', { className: styles.loadingCirclePoint }),\n\t                            _react2.default.createElement('div', { className: styles.loadingCirclePoint }),\n\t                            _react2.default.createElement('div', { className: styles.loadingCirclePoint }),\n\t                            _react2.default.createElement('div', { className: styles.loadingCirclePoint }),\n\t                            _react2.default.createElement('div', { className: styles.loadingCirclePoint }),\n\t                            _react2.default.createElement('div', { className: styles.loadingCirclePoint }),\n\t                            _react2.default.createElement('div', { className: styles.loadingCirclePoint }),\n\t                            _react2.default.createElement('div', { className: styles.loadingCirclePoint }),\n\t                            _react2.default.createElement('div', { className: styles.loadingCirclePoint }),\n\t                            _react2.default.createElement('div', { className: styles.loadingCirclePoint })\n\t                        )\n\t                    );\n\t                } else {\n\t                    // Show the handle used to initiate a drag-and-drop\n\t                    handle = connectDragSource(_react2.default.createElement('div', { className: styles.moveHandle }), { dropEffect: 'copy' });\n\t                }\n\t            }\n\t\n\t            var isDraggedDescendant = draggedNode && (0, _treeDataUtils.isDescendant)(draggedNode, node);\n\t            var isLandingPadActive = !didDrop && isDragging;\n\t\n\t            return _react2.default.createElement(\n\t                'div',\n\t                _extends({\n\t                    style: { height: '100%' }\n\t                }, otherProps),\n\t                toggleChildrenVisibility && node.children && node.children.length > 0 && _react2.default.createElement(\n\t                    'div',\n\t                    null,\n\t                    _react2.default.createElement('button', {\n\t                        type: 'button',\n\t                        'aria-label': node.expanded ? 'Collapse' : 'Expand',\n\t                        className: node.expanded ? styles.collapseButton : styles.expandButton,\n\t                        style: { left: -0.5 * scaffoldBlockPxWidth },\n\t                        onClick: function onClick() {\n\t                            return toggleChildrenVisibility({ node: node, path: path, treeIndex: treeIndex });\n\t                        }\n\t                    }),\n\t                    node.expanded && !isDragging && _react2.default.createElement('div', {\n\t                        style: { width: scaffoldBlockPxWidth },\n\t                        className: styles.lineChildren\n\t                    })\n\t                ),\n\t                _react2.default.createElement(\n\t                    'div',\n\t                    { className: styles.rowWrapper },\n\t                    connectDragPreview(_react2.default.createElement(\n\t                        'div',\n\t                        {\n\t                            className: styles.row + (isLandingPadActive ? ' ' + styles.rowLandingPad : '') + (isLandingPadActive && !canDrop ? ' ' + styles.rowCancelPad : '') + (isSearchMatch ? ' ' + styles.rowSearchMatch : '') + (isSearchFocus ? ' ' + styles.rowSearchFocus : '') + (className ? ' ' + className : ''),\n\t                            style: _extends({\n\t                                opacity: isDraggedDescendant ? 0.5 : 1\n\t                            }, style)\n\t                        },\n\t                        handle,\n\t                        _react2.default.createElement(\n\t                            'div',\n\t                            {\n\t                                className: styles.rowContents + (!canDrag ? ' ' + styles.rowContentsDragDisabled : '')\n\t                            },\n\t                            _react2.default.createElement(\n\t                                'div',\n\t                                { className: styles.rowLabel },\n\t                                _react2.default.createElement(\n\t                                    'span',\n\t                                    {\n\t                                        className: styles.rowTitle + (node.subtitle ? ' ' + styles.rowTitleWithSubtitle : '')\n\t                                    },\n\t                                    typeof node.title === 'function' ? node.title({ node: node, path: path, treeIndex: treeIndex }) : node.title\n\t                                ),\n\t                                node.subtitle && _react2.default.createElement(\n\t                                    'span',\n\t                                    { className: styles.rowSubtitle },\n\t                                    typeof node.subtitle === 'function' ? node.subtitle({ node: node, path: path, treeIndex: treeIndex }) : node.subtitle\n\t                                )\n\t                            ),\n\t                            _react2.default.createElement(\n\t                                'div',\n\t                                { className: styles.rowToolbar },\n\t                                buttons && buttons.map(function (btn, index) {\n\t                                    return _react2.default.createElement(\n\t                                        'div',\n\t                                        { key: index, className: styles.toolbarButton },\n\t                                        btn\n\t                                    );\n\t                                })\n\t                            )\n\t                        )\n\t                    ))\n\t                )\n\t            );\n\t        }\n\t    }]);\n\t\n\t    return NodeRendererDefault;\n\t}(_react.Component);\n\t\n\tNodeRendererDefault.propTypes = {\n\t    node: _propTypes2.default.object.isRequired,\n\t    path: _propTypes2.default.arrayOf(_propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number])).isRequired,\n\t    treeIndex: _propTypes2.default.number.isRequired,\n\t    isSearchMatch: _propTypes2.default.bool,\n\t    isSearchFocus: _propTypes2.default.bool,\n\t    canDrag: _propTypes2.default.bool,\n\t    scaffoldBlockPxWidth: _propTypes2.default.number.isRequired,\n\t    toggleChildrenVisibility: _propTypes2.default.func,\n\t    buttons: _propTypes2.default.arrayOf(_propTypes2.default.node),\n\t    className: _propTypes2.default.string,\n\t    style: _propTypes2.default.object,\n\t\n\t    // Drag and drop API functions\n\t    // Drag source\n\t    connectDragPreview: _propTypes2.default.func.isRequired,\n\t    connectDragSource: _propTypes2.default.func.isRequired,\n\t    parentNode: _propTypes2.default.object, // Needed for drag-and-drop utils\n\t    startDrag: _propTypes2.default.func.isRequired, // Needed for drag-and-drop utils\n\t    endDrag: _propTypes2.default.func.isRequired, // Needed for drag-and-drop utils\n\t    isDragging: _propTypes2.default.bool.isRequired,\n\t    didDrop: _propTypes2.default.bool.isRequired,\n\t    draggedNode: _propTypes2.default.object,\n\t    // Drop target\n\t    isOver: _propTypes2.default.bool.isRequired,\n\t    canDrop: _propTypes2.default.bool\n\t};\n\t\n\texports.default = NodeRendererDefault;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.SortableTreeWithoutDndContext = undefined;\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _react = __webpack_require__(5);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _propTypes = __webpack_require__(4);\n\t\n\tvar _propTypes2 = _interopRequireDefault(_propTypes);\n\t\n\tvar _reactVirtualized = __webpack_require__(26);\n\t\n\tvar _lodash = __webpack_require__(22);\n\t\n\tvar _lodash2 = _interopRequireDefault(_lodash);\n\t\n\tvar _reactDndScrollzone = __webpack_require__(25);\n\t\n\tvar _reactDndScrollzone2 = _interopRequireDefault(_reactDndScrollzone);\n\t\n\t__webpack_require__(18);\n\t\n\tvar _treeNode = __webpack_require__(10);\n\t\n\tvar _treeNode2 = _interopRequireDefault(_treeNode);\n\t\n\tvar _nodeRendererDefault = __webpack_require__(8);\n\t\n\tvar _nodeRendererDefault2 = _interopRequireDefault(_nodeRendererDefault);\n\t\n\tvar _treeDataUtils = __webpack_require__(1);\n\t\n\tvar _memoizedTreeDataUtils = __webpack_require__(7);\n\t\n\tvar _genericUtils = __webpack_require__(13);\n\t\n\tvar _defaultHandlers = __webpack_require__(6);\n\t\n\tvar _dragAndDropUtils = __webpack_require__(12);\n\t\n\tvar _reactSortableTree = __webpack_require__(20);\n\t\n\tvar _reactSortableTree2 = _interopRequireDefault(_reactSortableTree);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*!\r\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * react-sortable-tree\r\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2016 Chris Fritz All rights reserved.\r\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @license Open source under the MIT License\r\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\t\n\tvar dndTypeCounter = 1;\n\t\n\tvar ReactSortableTree = function (_Component) {\n\t    _inherits(ReactSortableTree, _Component);\n\t\n\t    function ReactSortableTree(props) {\n\t        _classCallCheck(this, ReactSortableTree);\n\t\n\t        var _this = _possibleConstructorReturn(this, (ReactSortableTree.__proto__ || Object.getPrototypeOf(ReactSortableTree)).call(this, props));\n\t\n\t        var dndType = props.dndType,\n\t            nodeContentRenderer = props.nodeContentRenderer,\n\t            isVirtualized = props.isVirtualized,\n\t            slideRegionSize = props.slideRegionSize,\n\t            treeData = props.treeData;\n\t\n\t        // Wrapping classes for use with react-dnd\n\t\n\t        _this.dndType = dndType || 'rst__' + dndTypeCounter++;\n\t        _this.nodeContentRenderer = (0, _dragAndDropUtils.dndWrapSource)(nodeContentRenderer, _this.dndType);\n\t        _this.treeNodeRenderer = (0, _dragAndDropUtils.dndWrapTarget)(_treeNode2.default, _this.dndType);\n\t\n\t        // Prepare scroll-on-drag options for this list\n\t        if (isVirtualized) {\n\t            _this.scrollZoneVirtualList = (0, _reactDndScrollzone2.default)(_reactVirtualized.List);\n\t            _this.vStrength = (0, _reactDndScrollzone.createVerticalStrength)(slideRegionSize);\n\t            _this.hStrength = (0, _reactDndScrollzone.createHorizontalStrength)(slideRegionSize);\n\t        }\n\t\n\t        _this.state = {\n\t            draggingTreeData: null,\n\t            swapFrom: null,\n\t            swapLength: null,\n\t            swapDepth: null,\n\t            rows: _this.getRows(treeData),\n\t            searchMatches: [],\n\t            searchFocusTreeIndex: null\n\t        };\n\t\n\t        _this.toggleChildrenVisibility = _this.toggleChildrenVisibility.bind(_this);\n\t        _this.moveNode = _this.moveNode.bind(_this);\n\t        _this.startDrag = _this.startDrag.bind(_this);\n\t        _this.dragHover = _this.dragHover.bind(_this);\n\t        _this.endDrag = _this.endDrag.bind(_this);\n\t        return _this;\n\t    }\n\t\n\t    _createClass(ReactSortableTree, [{\n\t        key: 'componentWillMount',\n\t        value: function componentWillMount() {\n\t            this.loadLazyChildren();\n\t            this.search(this.props, false, false);\n\t            this.ignoreOneTreeUpdate = false;\n\t        }\n\t    }, {\n\t        key: 'toggleChildrenVisibility',\n\t        value: function toggleChildrenVisibility(_ref) {\n\t            var targetNode = _ref.node,\n\t                path = _ref.path,\n\t                _treeIndex = _ref.treeIndex;\n\t\n\t            var treeData = (0, _treeDataUtils.changeNodeAtPath)({\n\t                treeData: this.props.treeData,\n\t                path: path,\n\t                newNode: function newNode(_ref2) {\n\t                    var node = _ref2.node;\n\t                    return _extends({}, node, { expanded: !node.expanded });\n\t                },\n\t                getNodeKey: this.props.getNodeKey\n\t            });\n\t\n\t            this.props.onChange(treeData);\n\t\n\t            if (this.props.onVisibilityToggle) {\n\t                this.props.onVisibilityToggle({\n\t                    treeData: treeData,\n\t                    node: targetNode,\n\t                    expanded: !targetNode.expanded\n\t                });\n\t            }\n\t        }\n\t    }, {\n\t        key: 'moveNode',\n\t        value: function moveNode(_ref3) {\n\t            var node = _ref3.node,\n\t                depth = _ref3.depth,\n\t                minimumTreeIndex = _ref3.minimumTreeIndex;\n\t\n\t            var _insertNode = (0, _treeDataUtils.insertNode)({\n\t                treeData: this.state.draggingTreeData,\n\t                newNode: node,\n\t                depth: depth,\n\t                minimumTreeIndex: minimumTreeIndex,\n\t                expandParent: true,\n\t                getNodeKey: this.props.getNodeKey\n\t            }),\n\t                treeData = _insertNode.treeData,\n\t                treeIndex = _insertNode.treeIndex,\n\t                path = _insertNode.path;\n\t\n\t            this.props.onChange(treeData);\n\t\n\t            if (this.props.onMoveNode) {\n\t                this.props.onMoveNode({ treeData: treeData, node: node, treeIndex: treeIndex, path: path });\n\t            }\n\t        }\n\t    }, {\n\t        key: 'componentWillReceiveProps',\n\t        value: function componentWillReceiveProps(nextProps) {\n\t            this.setState({ searchFocusTreeIndex: null });\n\t            if (this.props.treeData !== nextProps.treeData) {\n\t                // Ignore updates caused by search, in order to avoid infinite looping\n\t                if (this.ignoreOneTreeUpdate) {\n\t                    this.ignoreOneTreeUpdate = false;\n\t                } else {\n\t                    this.loadLazyChildren(nextProps);\n\t                    // Load any children defined by a function\n\t                    this.search(nextProps, false, false);\n\t                }\n\t\n\t                // Calculate the rows to be shown from the new tree data\n\t                this.setState({\n\t                    draggingTreeData: null,\n\t                    swapFrom: null,\n\t                    swapLength: null,\n\t                    swapDepth: null,\n\t                    rows: this.getRows(nextProps.treeData)\n\t                });\n\t            } else if (!(0, _lodash2.default)(this.props.searchQuery, nextProps.searchQuery)) {\n\t                this.search(nextProps);\n\t            } else if (this.props.searchFocusOffset !== nextProps.searchFocusOffset) {\n\t                this.search(nextProps, true, true, true);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'getRows',\n\t        value: function getRows(treeData) {\n\t            return (0, _treeDataUtils.getFlatDataFromTree)({\n\t                ignoreCollapsed: true,\n\t                getNodeKey: this.props.getNodeKey,\n\t                treeData: treeData\n\t            });\n\t        }\n\t    }, {\n\t        key: 'search',\n\t        value: function search() {\n\t            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n\t            var seekIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t            var expand = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\t            var singleSearch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\t            var treeData = props.treeData,\n\t                onChange = props.onChange,\n\t                searchFinishCallback = props.searchFinishCallback,\n\t                searchQuery = props.searchQuery,\n\t                searchMethod = props.searchMethod,\n\t                searchFocusOffset = props.searchFocusOffset;\n\t\n\t            // Skip search if no conditions are specified\n\t\n\t            if ((searchQuery === null || typeof searchQuery === 'undefined' || String(searchQuery) === '') && !searchMethod) {\n\t                this.setState({\n\t                    searchMatches: []\n\t                });\n\t\n\t                if (searchFinishCallback) {\n\t                    searchFinishCallback([]);\n\t                }\n\t\n\t                return;\n\t            }\n\t\n\t            var _find = (0, _treeDataUtils.find)({\n\t                getNodeKey: this.props.getNodeKey,\n\t                treeData: treeData,\n\t                searchQuery: searchQuery,\n\t                searchMethod: searchMethod || _defaultHandlers.defaultSearchMethod,\n\t                searchFocusOffset: searchFocusOffset,\n\t                expandAllMatchPaths: expand && !singleSearch,\n\t                expandFocusMatchPaths: expand && true\n\t            }),\n\t                expandedTreeData = _find.treeData,\n\t                searchMatches = _find.matches;\n\t\n\t            // Update the tree with data leaving all paths leading to matching nodes open\n\t\n\t\n\t            if (expand) {\n\t                this.ignoreOneTreeUpdate = true; // Prevents infinite loop\n\t                onChange(expandedTreeData);\n\t            }\n\t\n\t            if (searchFinishCallback) {\n\t                searchFinishCallback(searchMatches);\n\t            }\n\t\n\t            var searchFocusTreeIndex = null;\n\t            if (seekIndex && searchFocusOffset !== null && searchFocusOffset < searchMatches.length) {\n\t                searchFocusTreeIndex = searchMatches[searchFocusOffset].treeIndex;\n\t            }\n\t\n\t            this.setState({\n\t                searchMatches: searchMatches,\n\t                searchFocusTreeIndex: searchFocusTreeIndex\n\t            });\n\t        }\n\t    }, {\n\t        key: 'startDrag',\n\t        value: function startDrag(_ref4) {\n\t            var path = _ref4.path;\n\t\n\t            if (this.props.freeze) return;\n\t            var draggingTreeData = (0, _treeDataUtils.removeNodeAtPath)({\n\t                treeData: this.props.treeData,\n\t                path: path,\n\t                getNodeKey: this.props.getNodeKey\n\t            });\n\t\n\t            this.setState({\n\t                draggingTreeData: draggingTreeData\n\t            });\n\t        }\n\t    }, {\n\t        key: 'dragHover',\n\t        value: function dragHover(_ref5) {\n\t            var draggedNode = _ref5.node,\n\t                depth = _ref5.depth,\n\t                minimumTreeIndex = _ref5.minimumTreeIndex;\n\t\n\t            if (this.props.freeze) return;\n\t            var addedResult = (0, _memoizedTreeDataUtils.memoizedInsertNode)({\n\t                treeData: this.state.draggingTreeData,\n\t                newNode: draggedNode,\n\t                depth: depth,\n\t                minimumTreeIndex: minimumTreeIndex,\n\t                expandParent: true,\n\t                getNodeKey: this.props.getNodeKey\n\t            });\n\t\n\t            var rows = this.getRows(addedResult.treeData);\n\t            var expandedParentPath = rows[addedResult.treeIndex].path;\n\t\n\t            var swapFrom = addedResult.treeIndex;\n\t            var swapTo = minimumTreeIndex;\n\t            var swapLength = 1 + (0, _treeDataUtils.getDescendantCount)({ node: draggedNode });\n\t            this.setState({\n\t                rows: (0, _genericUtils.swapRows)(rows, swapFrom, swapTo, swapLength),\n\t                swapFrom: swapFrom,\n\t                swapLength: swapLength,\n\t                swapDepth: depth,\n\t                draggingTreeData: (0, _treeDataUtils.changeNodeAtPath)({\n\t                    treeData: this.state.draggingTreeData,\n\t                    path: expandedParentPath.slice(0, -1),\n\t                    newNode: function newNode(_ref6) {\n\t                        var node = _ref6.node;\n\t                        return _extends({}, node, { expanded: true });\n\t                    },\n\t                    getNodeKey: this.props.getNodeKey\n\t                })\n\t            });\n\t        }\n\t    }, {\n\t        key: 'endDrag',\n\t        value: function endDrag(dropResult) {\n\t            if (this.props.freeze) return;\n\t            if (!dropResult || !dropResult.node) {\n\t                return this.setState({\n\t                    draggingTreeData: null,\n\t                    swapFrom: null,\n\t                    swapLength: null,\n\t                    swapDepth: null,\n\t                    rows: this.getRows(this.props.treeData)\n\t                });\n\t            }\n\t\n\t            this.moveNode(dropResult);\n\t        }\n\t\n\t        /**\r\n\t         * Load any children in the tree that are given by a function\r\n\t         */\n\t\n\t    }, {\n\t        key: 'loadLazyChildren',\n\t        value: function loadLazyChildren() {\n\t            var _this2 = this;\n\t\n\t            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n\t\n\t            (0, _treeDataUtils.walk)({\n\t                treeData: props.treeData,\n\t                getNodeKey: this.props.getNodeKey,\n\t                callback: function callback(_ref7) {\n\t                    var node = _ref7.node,\n\t                        path = _ref7.path,\n\t                        lowerSiblingCounts = _ref7.lowerSiblingCounts,\n\t                        treeIndex = _ref7.treeIndex;\n\t\n\t                    // If the node has children defined by a function, and is either expanded\n\t                    //  or set to load even before expansion, run the function.\n\t                    if (node.children && typeof node.children === 'function' && (node.expanded || props.loadCollapsedLazyChildren)) {\n\t                        // Call the children fetching function\n\t                        node.children({\n\t                            node: node,\n\t                            path: path,\n\t                            lowerSiblingCounts: lowerSiblingCounts,\n\t                            treeIndex: treeIndex,\n\t\n\t                            // Provide a helper to append the new data when it is received\n\t                            done: function done(childrenArray) {\n\t                                return _this2.props.onChange((0, _treeDataUtils.changeNodeAtPath)({\n\t                                    treeData: _this2.props.treeData,\n\t                                    path: path,\n\t                                    newNode: function newNode(_ref8) {\n\t                                        var oldNode = _ref8.node;\n\t                                        return (\n\t                                            // Only replace the old node if it's the one we set off to find children\n\t                                            //  for in the first place\n\t                                            oldNode === node ? _extends({}, oldNode, { children: childrenArray }) : oldNode\n\t                                        );\n\t                                    },\n\t                                    getNodeKey: _this2.props.getNodeKey\n\t                                }));\n\t                            }\n\t                        });\n\t                    }\n\t                }\n\t            });\n\t        }\n\t    }, {\n\t        key: 'render',\n\t        value: function render() {\n\t            var _this3 = this;\n\t\n\t            var _props = this.props,\n\t                style = _props.style,\n\t                className = _props.className,\n\t                innerStyle = _props.innerStyle,\n\t                rowHeight = _props.rowHeight,\n\t                getNodeKey = _props.getNodeKey,\n\t                isVirtualized = _props.isVirtualized;\n\t            var _state = this.state,\n\t                rows = _state.rows,\n\t                searchMatches = _state.searchMatches,\n\t                searchFocusTreeIndex = _state.searchFocusTreeIndex;\n\t\n\t            // Get indices for rows that match the search conditions\n\t\n\t            var matchKeys = {};\n\t            searchMatches.forEach(function (_ref9, i) {\n\t                var path = _ref9.path;\n\t                matchKeys[path[path.length - 1]] = i;\n\t            });\n\t\n\t            // Seek to the focused search result if there is one specified\n\t            var scrollToInfo = searchFocusTreeIndex !== null ? { scrollToIndex: searchFocusTreeIndex } : {};\n\t\n\t            var containerStyle = style;\n\t            var list = void 0;\n\t            if (isVirtualized) {\n\t                containerStyle = _extends({ height: '100%' }, containerStyle);\n\t\n\t                var ScrollZoneVirtualList = this.scrollZoneVirtualList;\n\t                // Render list with react-virtualized\n\t                list = _react2.default.createElement(\n\t                    _reactVirtualized.AutoSizer,\n\t                    null,\n\t                    function (_ref10) {\n\t                        var height = _ref10.height,\n\t                            width = _ref10.width;\n\t                        return _react2.default.createElement(ScrollZoneVirtualList, _extends({}, scrollToInfo, {\n\t                            verticalStrength: _this3.vStrength,\n\t                            horizontalStrength: _this3.hStrength,\n\t                            speed: 30,\n\t                            scrollToAlignment: 'start',\n\t                            className: _reactSortableTree2.default.virtualScrollOverride,\n\t                            width: width,\n\t                            onScroll: function onScroll(_ref11) {\n\t                                var scrollTop = _ref11.scrollTop;\n\t                                _this3.scrollTop = scrollTop;\n\t                            },\n\t                            height: height,\n\t                            style: innerStyle,\n\t                            rowCount: rows.length,\n\t                            estimatedRowSize: typeof rowHeight !== 'function' ? rowHeight : undefined,\n\t                            rowHeight: rowHeight,\n\t                            rowRenderer: function rowRenderer(_ref12) {\n\t                                var index = _ref12.index,\n\t                                    key = _ref12.key,\n\t                                    rowStyle = _ref12.style;\n\t                                return _this3.renderRow(rows[index], index, key, rowStyle, function () {\n\t                                    return rows[index - 1] || null;\n\t                                }, matchKeys);\n\t                            }\n\t                        }, _this3.props.reactVirtualizedListProps));\n\t                    }\n\t                );\n\t            } else {\n\t                // Render list without react-virtualized\n\t                list = rows.map(function (row, index) {\n\t                    return _this3.renderRow(row, index, getNodeKey({\n\t                        node: row.node,\n\t                        treeIndex: row.treeIndex\n\t                    }), { height: typeof rowHeight !== 'function' ? rowHeight : rowHeight({ index: index }) }, function () {\n\t                        return rows[index - 1] || null;\n\t                    }, matchKeys);\n\t                });\n\t            }\n\t\n\t            return _react2.default.createElement(\n\t                'div',\n\t                {\n\t                    className: _reactSortableTree2.default.tree + (className ? ' ' + className : ''),\n\t                    style: containerStyle\n\t                },\n\t                list\n\t            );\n\t        }\n\t    }, {\n\t        key: 'renderRow',\n\t        value: function renderRow(_ref13, listIndex, key, style, getPrevRow, matchKeys) {\n\t            var node = _ref13.node,\n\t                parentNode = _ref13.parentNode,\n\t                path = _ref13.path,\n\t                lowerSiblingCounts = _ref13.lowerSiblingCounts,\n\t                treeIndex = _ref13.treeIndex;\n\t            var _props2 = this.props,\n\t                canDrag = _props2.canDrag,\n\t                canDrop = _props2.canDrop,\n\t                generateNodeProps = _props2.generateNodeProps,\n\t                getNodeKey = _props2.getNodeKey,\n\t                maxDepth = _props2.maxDepth,\n\t                scaffoldBlockPxWidth = _props2.scaffoldBlockPxWidth,\n\t                searchFocusOffset = _props2.searchFocusOffset,\n\t                freeze = _props2.freeze;\n\t\n\t            var TreeNodeRenderer = this.treeNodeRenderer;\n\t            var NodeContentRenderer = this.nodeContentRenderer;\n\t            var nodeKey = path[path.length - 1];\n\t            var isSearchMatch = nodeKey in matchKeys;\n\t            var isSearchFocus = isSearchMatch && matchKeys[nodeKey] === searchFocusOffset;\n\t            var callbackParams = {\n\t                node: node,\n\t                parentNode: parentNode,\n\t                path: path,\n\t                lowerSiblingCounts: lowerSiblingCounts,\n\t                treeIndex: treeIndex,\n\t                isSearchMatch: isSearchMatch,\n\t                isSearchFocus: isSearchFocus\n\t            };\n\t            var nodeProps = !generateNodeProps ? {} : generateNodeProps(callbackParams);\n\t            var rowCanDrag = typeof canDrag !== 'function' ? canDrag : canDrag(callbackParams);\n\t\n\t            return _react2.default.createElement(\n\t                TreeNodeRenderer,\n\t                {\n\t                    style: style,\n\t                    key: key,\n\t                    treeIndex: treeIndex,\n\t                    listIndex: listIndex,\n\t                    getPrevRow: getPrevRow,\n\t                    treeData: this.state.draggingTreeData || this.state.treeData,\n\t                    getNodeKey: getNodeKey,\n\t                    customCanDrop: canDrop,\n\t                    node: node,\n\t                    path: path,\n\t                    lowerSiblingCounts: lowerSiblingCounts,\n\t                    scaffoldBlockPxWidth: scaffoldBlockPxWidth,\n\t                    swapFrom: this.state.swapFrom,\n\t                    swapLength: this.state.swapLength,\n\t                    swapDepth: this.state.swapDepth,\n\t                    maxDepth: maxDepth,\n\t                    dragHover: this.dragHover\n\t                },\n\t                _react2.default.createElement(NodeContentRenderer, _extends({\n\t                    node: node,\n\t                    parentNode: parentNode,\n\t                    path: path,\n\t                    isSearchMatch: isSearchMatch,\n\t                    isSearchFocus: isSearchFocus,\n\t                    treeIndex: treeIndex,\n\t                    startDrag: this.startDrag,\n\t                    endDrag: this.endDrag,\n\t                    canDrag: rowCanDrag,\n\t                    toggleChildrenVisibility: this.toggleChildrenVisibility,\n\t                    scaffoldBlockPxWidth: scaffoldBlockPxWidth,\n\t                    freeze: freeze\n\t                }, nodeProps))\n\t            );\n\t        }\n\t    }]);\n\t\n\t    return ReactSortableTree;\n\t}(_react.Component);\n\t\n\tReactSortableTree.propTypes = {\n\t    // Tree data in the following format:\n\t    // [{title: 'main', subtitle: 'sub'}, { title: 'value2', expanded: true, children: [{ title: 'value3') }] }]\n\t    // `title` is the primary label for the node\n\t    // `subtitle` is a secondary label for the node\n\t    // `expanded` shows children of the node if true, or hides them if false. Defaults to false.\n\t    // `children` is an array of child nodes belonging to the node.\n\t    treeData: _propTypes2.default.arrayOf(_propTypes2.default.object).isRequired,\n\t\n\t    // Style applied to the container wrapping the tree (style defaults to {height: '100%'})\n\t    style: _propTypes2.default.object,\n\t\n\t    // Class name for the container wrapping the tree\n\t    className: _propTypes2.default.string,\n\t\n\t    // Style applied to the inner, scrollable container (for padding, etc.)\n\t    innerStyle: _propTypes2.default.object,\n\t\n\t    // Used by react-virtualized\n\t    // Either a fixed row height (number) or a function that returns the\n\t    // height of a row given its index: `({ index: number }): number`\n\t    rowHeight: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.func]),\n\t\n\t    // Size in px of the region near the edges that initiates scrolling on dragover\n\t    slideRegionSize: _propTypes2.default.number.isRequired, // eslint-disable-line react/no-unused-prop-types\n\t\n\t    // Custom properties to hand to the react-virtualized list\n\t    // https://github.com/bvaughn/react-virtualized/blob/master/docs/List.md#prop-types\n\t    reactVirtualizedListProps: _propTypes2.default.object,\n\t\n\t    // The width of the blocks containing the lines representing the structure of the tree.\n\t    scaffoldBlockPxWidth: _propTypes2.default.number,\n\t\n\t    // Maximum depth nodes can be inserted at. Defaults to infinite.\n\t    maxDepth: _propTypes2.default.number,\n\t\n\t    // The method used to search nodes.\n\t    // Defaults to a function that uses the `searchQuery` string to search for nodes with\n\t    // matching `title` or `subtitle` values.\n\t    // NOTE: Changing `searchMethod` will not update the search, but changing the `searchQuery` will.\n\t    searchMethod: _propTypes2.default.func, // eslint-disable-line react/no-unused-prop-types\n\t\n\t    // Used by the `searchMethod` to highlight and scroll to matched nodes.\n\t    // Should be a string for the default `searchMethod`, but can be anything when using a custom search.\n\t    searchQuery: _propTypes2.default.any,\n\t\n\t    // Outline the <`searchFocusOffset`>th node and scroll to it.\n\t    searchFocusOffset: _propTypes2.default.number,\n\t\n\t    // Get the nodes that match the search criteria. Used for counting total matches, etc.\n\t    searchFinishCallback: _propTypes2.default.func, // eslint-disable-line react/no-unused-prop-types\n\t\n\t    // Generate an object with additional props to be passed to the node renderer.\n\t    // Use this for adding buttons via the `buttons` key,\n\t    // or additional `style` / `className` settings.\n\t    generateNodeProps: _propTypes2.default.func,\n\t\n\t    // Set to false to disable virtualization.\n\t    // NOTE: Auto-scrolling while dragging, and scrolling to the `searchFocusOffset` will be disabled.\n\t    isVirtualized: _propTypes2.default.bool,\n\t\n\t    // Override the default component for rendering nodes (but keep the scaffolding generator)\n\t    // This is an advanced option for complete customization of the appearance.\n\t    // It is best to copy the component in `node-renderer-default.js` to use as a base, and customize as needed.\n\t    nodeContentRenderer: _propTypes2.default.any,\n\t\n\t    // Determine the unique key used to identify each node and\n\t    // generate the `path` array passed in callbacks.\n\t    // By default, returns the index in the tree (omitting hidden nodes).\n\t    getNodeKey: _propTypes2.default.func,\n\t\n\t    // Called whenever tree data changed.\n\t    // Just like with React input elements, you have to update your\n\t    // own component's data to see the changes reflected.\n\t    onChange: _propTypes2.default.func.isRequired,\n\t\n\t    // Called after node move operation.\n\t    onMoveNode: _propTypes2.default.func,\n\t\n\t    // Determine whether a node can be dragged. Set to false to disable dragging on all nodes.\n\t    canDrag: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.bool]),\n\t\n\t    // Determine whether a node can be dropped based on its path and parents'.\n\t    canDrop: _propTypes2.default.func,\n\t\n\t    // Called after children nodes collapsed or expanded.\n\t    onVisibilityToggle: _propTypes2.default.func,\n\t\n\t    dndType: _propTypes2.default.string,\n\t\n\t    // Prevent tree from rebuilding on dragging\n\t    freeze: _propTypes2.default.bool\n\t};\n\t\n\tReactSortableTree.defaultProps = {\n\t    getNodeKey: _defaultHandlers.defaultGetNodeKey,\n\t    nodeContentRenderer: _nodeRendererDefault2.default,\n\t    rowHeight: 62,\n\t    slideRegionSize: 100,\n\t    scaffoldBlockPxWidth: 44,\n\t    style: {},\n\t    innerStyle: {},\n\t    searchQuery: null,\n\t    isVirtualized: true,\n\t    canDrag: true,\n\t    freeze: false\n\t};\n\t\n\t// Export the tree component without the react-dnd DragDropContext,\n\t// for when component is used with other components using react-dnd.\n\t// see: https://github.com/gaearon/react-dnd/issues/186\n\texports.SortableTreeWithoutDndContext = ReactSortableTree;\n\texports.default = (0, _dragAndDropUtils.dndWrapRoot)(ReactSortableTree);\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _react = __webpack_require__(5);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _propTypes = __webpack_require__(4);\n\t\n\tvar _propTypes2 = _interopRequireDefault(_propTypes);\n\t\n\tvar _treeNode = __webpack_require__(21);\n\t\n\tvar _treeNode2 = _interopRequireDefault(_treeNode);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar TreeNode = function (_Component) {\n\t    _inherits(TreeNode, _Component);\n\t\n\t    function TreeNode() {\n\t        _classCallCheck(this, TreeNode);\n\t\n\t        return _possibleConstructorReturn(this, (TreeNode.__proto__ || Object.getPrototypeOf(TreeNode)).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(TreeNode, [{\n\t        key: 'render',\n\t        value: function render() {\n\t            var _props = this.props,\n\t                children = _props.children,\n\t                listIndex = _props.listIndex,\n\t                swapFrom = _props.swapFrom,\n\t                swapLength = _props.swapLength,\n\t                swapDepth = _props.swapDepth,\n\t                scaffoldBlockPxWidth = _props.scaffoldBlockPxWidth,\n\t                lowerSiblingCounts = _props.lowerSiblingCounts,\n\t                connectDropTarget = _props.connectDropTarget,\n\t                isOver = _props.isOver,\n\t                draggedNode = _props.draggedNode,\n\t                canDrop = _props.canDrop,\n\t                treeIndex = _props.treeIndex,\n\t                _customCanDrop = _props.customCanDrop,\n\t                _dragHover = _props.dragHover,\n\t                _getNodeKey = _props.getNodeKey,\n\t                _getPrevRow = _props.getPrevRow,\n\t                _maxDepth = _props.maxDepth,\n\t                _node = _props.node,\n\t                _path = _props.path,\n\t                _treeData = _props.treeData,\n\t                otherProps = _objectWithoutProperties(_props, ['children', 'listIndex', 'swapFrom', 'swapLength', 'swapDepth', 'scaffoldBlockPxWidth', 'lowerSiblingCounts', 'connectDropTarget', 'isOver', 'draggedNode', 'canDrop', 'treeIndex', 'customCanDrop', 'dragHover', 'getNodeKey', 'getPrevRow', 'maxDepth', 'node', 'path', 'treeData']);\n\t\n\t            // Construct the scaffold representing the structure of the tree\n\t\n\t\n\t            var scaffoldBlockCount = lowerSiblingCounts.length;\n\t            var scaffold = [];\n\t            lowerSiblingCounts.forEach(function (lowerSiblingCount, i) {\n\t                var lineClass = '';\n\t                if (lowerSiblingCount > 0) {\n\t                    // At this level in the tree, the nodes had sibling nodes further down\n\t\n\t                    if (listIndex === 0) {\n\t                        // Top-left corner of the tree\n\t                        // +-----+\n\t                        // |     |\n\t                        // |  +--+\n\t                        // |  |  |\n\t                        // +--+--+\n\t                        lineClass = _treeNode2.default.lineHalfHorizontalRight + ' ' + _treeNode2.default.lineHalfVerticalBottom;\n\t                    } else if (i === scaffoldBlockCount - 1) {\n\t                        // Last scaffold block in the row, right before the row content\n\t                        // +--+--+\n\t                        // |  |  |\n\t                        // |  +--+\n\t                        // |  |  |\n\t                        // +--+--+\n\t                        lineClass = _treeNode2.default.lineHalfHorizontalRight + ' ' + _treeNode2.default.lineFullVertical;\n\t                    } else {\n\t                        // Simply connecting the line extending down to the next sibling on this level\n\t                        // +--+--+\n\t                        // |  |  |\n\t                        // |  |  |\n\t                        // |  |  |\n\t                        // +--+--+\n\t                        lineClass = _treeNode2.default.lineFullVertical;\n\t                    }\n\t                } else if (listIndex === 0) {\n\t                    // Top-left corner of the tree, but has no siblings\n\t                    // +-----+\n\t                    // |     |\n\t                    // |  +--+\n\t                    // |     |\n\t                    // +-----+\n\t                    lineClass = _treeNode2.default.lineHalfHorizontalRight;\n\t                } else if (i === scaffoldBlockCount - 1) {\n\t                    // The last or only node in this level of the tree\n\t                    // +--+--+\n\t                    // |  |  |\n\t                    // |  +--+\n\t                    // |     |\n\t                    // +-----+\n\t                    lineClass = _treeNode2.default.lineHalfVerticalTop + ' ' + _treeNode2.default.lineHalfHorizontalRight;\n\t                }\n\t\n\t                scaffold.push(_react2.default.createElement('div', {\n\t                    key: 'pre_' + i,\n\t                    style: { width: scaffoldBlockPxWidth },\n\t                    className: _treeNode2.default.lineBlock + ' ' + lineClass\n\t                }));\n\t\n\t                if (treeIndex !== listIndex && i === swapDepth) {\n\t                    // This row has been shifted, and is at the depth of\n\t                    // the line pointing to the new destination\n\t                    var highlightLineClass = '';\n\t\n\t                    if (listIndex === swapFrom + swapLength - 1) {\n\t                        // This block is on the bottom (target) line\n\t                        // This block points at the target block (where the row will go when released)\n\t                        highlightLineClass = _treeNode2.default.highlightBottomLeftCorner;\n\t                    } else if (treeIndex === swapFrom) {\n\t                        // This block is on the top (source) line\n\t                        highlightLineClass = _treeNode2.default.highlightTopLeftCorner;\n\t                    } else {\n\t                        // This block is between the bottom and top\n\t                        highlightLineClass = _treeNode2.default.highlightLineVertical;\n\t                    }\n\t\n\t                    scaffold.push(_react2.default.createElement('div', {\n\t                        key: 'highlight_' + i,\n\t                        style: {\n\t                            width: scaffoldBlockPxWidth,\n\t                            left: scaffoldBlockPxWidth * i\n\t                        },\n\t                        className: _treeNode2.default.absoluteLineBlock + ' ' + highlightLineClass\n\t                    }));\n\t                }\n\t            });\n\t\n\t            return connectDropTarget(_react2.default.createElement(\n\t                'div',\n\t                _extends({}, otherProps, {\n\t                    className: _treeNode2.default.node\n\t                }),\n\t                scaffold,\n\t                _react2.default.createElement(\n\t                    'div',\n\t                    {\n\t                        className: _treeNode2.default.nodeContent,\n\t                        style: { left: scaffoldBlockPxWidth * scaffoldBlockCount }\n\t                    },\n\t                    _react.Children.map(children, function (child) {\n\t                        return (0, _react.cloneElement)(child, {\n\t                            isOver: isOver,\n\t                            canDrop: canDrop,\n\t                            draggedNode: draggedNode\n\t                        });\n\t                    })\n\t                )\n\t            ));\n\t        }\n\t    }]);\n\t\n\t    return TreeNode;\n\t}(_react.Component);\n\t\n\tTreeNode.propTypes = {\n\t    treeIndex: _propTypes2.default.number.isRequired,\n\t    node: _propTypes2.default.object.isRequired,\n\t    path: _propTypes2.default.arrayOf(_propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number])).isRequired,\n\t    swapFrom: _propTypes2.default.number,\n\t    swapDepth: _propTypes2.default.number,\n\t    swapLength: _propTypes2.default.number,\n\t    scaffoldBlockPxWidth: _propTypes2.default.number.isRequired,\n\t    lowerSiblingCounts: _propTypes2.default.array.isRequired,\n\t\n\t    listIndex: _propTypes2.default.number.isRequired,\n\t    children: _propTypes2.default.node,\n\t\n\t    // Drop target\n\t    connectDropTarget: _propTypes2.default.func.isRequired,\n\t    isOver: _propTypes2.default.bool.isRequired,\n\t    canDrop: _propTypes2.default.bool,\n\t    draggedNode: _propTypes2.default.object,\n\t\n\t    customCanDrop: _propTypes2.default.func, // used in drag-and-drop-utils\n\t    dragHover: _propTypes2.default.func.isRequired, // used in drag-and-drop-utils\n\t    getNodeKey: _propTypes2.default.func, // used in drag-and-drop-utils\n\t    getPrevRow: _propTypes2.default.func, // used in drag-and-drop-utils\n\t    maxDepth: _propTypes2.default.number, // used in drag-and-drop-utils\n\t    treeData: _propTypes2.default.arrayOf(_propTypes2.default.object) };\n\t\n\texports.default = TreeNode;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.getIEVersion = getIEVersion;\n\t/**\r\n\t * Get the version of Internet Explorer in use, or undefined\r\n\t *\r\n\t * @return {?number} ieVersion - IE version as an integer, or undefined if not IE\r\n\t */\n\tfunction getIEVersion() {\n\t  var match = navigator.userAgent.match(/(?:MSIE |Trident\\/.*; rv:)(\\d+)/);\n\t  return match ? parseInt(match[1], 10) : undefined;\n\t}\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.dndWrapSource = dndWrapSource;\n\texports.dndWrapTarget = dndWrapTarget;\n\texports.dndWrapRoot = dndWrapRoot;\n\t\n\tvar _reactDnd = __webpack_require__(23);\n\t\n\tvar _reactDndHtml5Backend = __webpack_require__(24);\n\t\n\tvar _reactDndHtml5Backend2 = _interopRequireDefault(_reactDndHtml5Backend);\n\t\n\tvar _treeDataUtils = __webpack_require__(1);\n\t\n\tvar _memoizedTreeDataUtils = __webpack_require__(7);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar nodeDragSource = {\n\t    beginDrag: function beginDrag(props) {\n\t        props.startDrag(props);\n\t\n\t        return {\n\t            node: props.node,\n\t            parentNode: props.parentNode,\n\t            path: props.path,\n\t            treeIndex: props.treeIndex\n\t        };\n\t    },\n\t    endDrag: function endDrag(props, monitor) {\n\t        props.endDrag(monitor.getDropResult());\n\t    },\n\t    isDragging: function isDragging(props, monitor) {\n\t        var dropTargetNode = monitor.getItem().node;\n\t        var draggedNode = props.node;\n\t\n\t        return draggedNode === dropTargetNode;\n\t    }\n\t};\n\t\n\tfunction getTargetDepth(dropTargetProps, monitor) {\n\t    var dropTargetDepth = 0;\n\t    var draggedItem = monitor.getItem();\n\t    var rowAbove = dropTargetProps.getPrevRow();\n\t    if (rowAbove) {\n\t        // Limit the length of the path to the deepest possible\n\t        dropTargetDepth = Math.min(rowAbove.path.length, dropTargetProps.path.length);\n\t    }\n\t\n\t    var blocksOffset = Math.round(monitor.getDifferenceFromInitialOffset().x / dropTargetProps.scaffoldBlockPxWidth);\n\t\n\t    var targetDepth = Math.min(dropTargetDepth, Math.max(0, draggedItem.path.length + blocksOffset - 1));\n\t\n\t    // If a maxDepth is defined, constrain the target depth\n\t    if (typeof dropTargetProps.maxDepth !== 'undefined' && dropTargetProps.maxDepth !== null) {\n\t        var draggedNode = monitor.getItem().node;\n\t        var draggedChildDepth = (0, _treeDataUtils.getDepth)(draggedNode);\n\t\n\t        targetDepth = Math.min(targetDepth, dropTargetProps.maxDepth - draggedChildDepth - 1);\n\t    }\n\t\n\t    return targetDepth;\n\t}\n\t\n\tfunction canDrop(dropTargetProps, monitor) {\n\t    if (!monitor.isOver()) {\n\t        return false;\n\t    }\n\t\n\t    var rowAbove = dropTargetProps.getPrevRow();\n\t    var abovePath = rowAbove ? rowAbove.path : [];\n\t    var aboveNode = rowAbove ? rowAbove.node : {};\n\t    var targetDepth = getTargetDepth(dropTargetProps, monitor);\n\t\n\t    // Cannot drop if we're adding to the children of the row above and\n\t    //  the row above is a function\n\t    if (targetDepth >= abovePath.length && typeof aboveNode.children === 'function') {\n\t        return false;\n\t    }\n\t\n\t    if (typeof dropTargetProps.customCanDrop === 'function') {\n\t        var node = monitor.getItem().node;\n\t        var addedResult = (0, _memoizedTreeDataUtils.memoizedInsertNode)({\n\t            treeData: dropTargetProps.treeData,\n\t            newNode: node,\n\t            depth: targetDepth,\n\t            getNodeKey: dropTargetProps.getNodeKey,\n\t            minimumTreeIndex: dropTargetProps.listIndex,\n\t            expandParent: true\n\t        });\n\t\n\t        return dropTargetProps.customCanDrop({\n\t            node: node,\n\t            prevPath: monitor.getItem().path,\n\t            prevParent: monitor.getItem().parentNode,\n\t            prevTreeIndex: monitor.getItem().treeIndex,\n\t            nextPath: addedResult.path,\n\t            nextParent: addedResult.parentNode,\n\t            nextTreeIndex: addedResult.treeIndex\n\t        });\n\t    }\n\t\n\t    return true;\n\t}\n\t\n\tvar nodeDropTarget = {\n\t    drop: function drop(dropTargetProps, monitor) {\n\t        return {\n\t            node: monitor.getItem().node,\n\t            path: monitor.getItem().path,\n\t            minimumTreeIndex: dropTargetProps.treeIndex,\n\t            depth: getTargetDepth(dropTargetProps, monitor)\n\t        };\n\t    },\n\t    hover: function hover(dropTargetProps, monitor) {\n\t        var targetDepth = getTargetDepth(dropTargetProps, monitor);\n\t        var draggedNode = monitor.getItem().node;\n\t        var needsRedraw =\n\t        // Redraw if hovered above different nodes\n\t        dropTargetProps.node !== draggedNode ||\n\t        // Or hovered above the same node but at a different depth\n\t        targetDepth !== dropTargetProps.path.length - 1;\n\t\n\t        if (!needsRedraw) {\n\t            return;\n\t        }\n\t\n\t        dropTargetProps.dragHover({\n\t            node: draggedNode,\n\t            path: monitor.getItem().path,\n\t            minimumTreeIndex: dropTargetProps.listIndex,\n\t            depth: targetDepth\n\t        });\n\t    },\n\t\n\t\n\t    canDrop: canDrop\n\t};\n\t\n\tfunction nodeDragSourcePropInjection(connect, monitor) {\n\t    return {\n\t        connectDragSource: connect.dragSource(),\n\t        connectDragPreview: connect.dragPreview(),\n\t        isDragging: monitor.isDragging(),\n\t        didDrop: monitor.didDrop()\n\t    };\n\t}\n\t\n\tfunction nodeDropTargetPropInjection(connect, monitor) {\n\t    var dragged = monitor.getItem();\n\t    return {\n\t        connectDropTarget: connect.dropTarget(),\n\t        isOver: monitor.isOver(),\n\t        canDrop: monitor.canDrop(),\n\t        draggedNode: dragged ? dragged.node : null\n\t    };\n\t}\n\t\n\tfunction dndWrapSource(el, type) {\n\t    return (0, _reactDnd.DragSource)(type, nodeDragSource, nodeDragSourcePropInjection)(el);\n\t}\n\t\n\tfunction dndWrapTarget(el, type) {\n\t    return (0, _reactDnd.DropTarget)(type, nodeDropTarget, nodeDropTargetPropInjection)(el);\n\t}\n\t\n\tfunction dndWrapRoot(el) {\n\t    return (0, _reactDnd.DragDropContext)(_reactDndHtml5Backend2.default)(el);\n\t}\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.swapRows = swapRows;\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tfunction swapRows(rows, fromIndex, toIndex) {\n\t    var count = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\t\n\t    var rowsWithoutMoved = [].concat(_toConsumableArray(rows.slice(0, fromIndex)), _toConsumableArray(rows.slice(fromIndex + count)));\n\t\n\t    return [].concat(_toConsumableArray(rowsWithoutMoved.slice(0, toIndex)), _toConsumableArray(rows.slice(fromIndex, fromIndex + count)), _toConsumableArray(rowsWithoutMoved.slice(toIndex)));\n\t}\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(2)(undefined);\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".ReactVirtualized__Table__headerRow{font-weight:700;text-transform:uppercase}.ReactVirtualized__Table__headerRow,.ReactVirtualized__Table__row{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-direction:row;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;-ms-flex-align:center;-webkit-box-align:center;align-items:center}.ReactVirtualized__Table__headerTruncatedText{display:inline-block;max-width:100%;white-space:nowrap;text-overflow:ellipsis;overflow:hidden}.ReactVirtualized__Table__headerColumn,.ReactVirtualized__Table__rowColumn{margin-right:10px;min-width:0}.ReactVirtualized__Table__rowColumn{text-overflow:ellipsis;white-space:nowrap}.ReactVirtualized__Table__headerColumn:first-of-type,.ReactVirtualized__Table__rowColumn:first-of-type{margin-left:10px}.ReactVirtualized__Table__sortableHeaderColumn{cursor:pointer}.ReactVirtualized__Table__sortableHeaderIconContainer{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-align:center;-webkit-box-align:center;align-items:center}.ReactVirtualized__Table__sortableHeaderIcon{-ms-flex:0 0 24px;-webkit-box-flex:0;flex:0 0 24px;height:1em;width:1em;fill:currentColor}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(2)(undefined);\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".rst__rowWrapper{padding:10px 10px 10px 0;height:100%;box-sizing:border-box}.rst__row{height:100%;white-space:nowrap;display:-webkit-box;display:-ms-flexbox;display:flex}.rst__row>*{box-sizing:border-box}.rst__rowCancelPad,.rst__rowLandingPad{border:none!important;box-shadow:none!important;outline:none!important}.rst__rowCancelPad *,.rst__rowLandingPad *{opacity:0!important}.rst__rowCancelPad:before,.rst__rowLandingPad:before{background-color:#add8e6;border:3px dashed #fff;content:\\\"\\\";position:absolute;top:0;right:0;bottom:0;left:0;z-index:-1}.rst__rowCancelPad:before{background-color:#e6a8ad}.rst__rowSearchMatch{outline:3px solid #0080ff}.rst__rowSearchFocus{outline:3px solid #fc6421}.rst__loadingHandle,.rst__moveHandle,.rst__rowContents,.rst__rowLabel,.rst__rowLabel_NoFlex,.rst__rowToolbar,.rst__rowToolbar_NoFlex,.rst__toolbarButton{display:inline-block;vertical-align:middle}.rst__rowContents{position:relative;height:100%;border:1px solid #bbb;border-left:none;box-shadow:0 2px 2px -2px;padding:0 5px 0 10px;border-radius:2px;min-width:230px;-webkit-box-flex:1;-ms-flex:1 0 auto;flex:1 0 auto;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;background-color:#fff}.rst__rowContentsDragDisabled{border-left:1px solid #bbb}.rst__rowLabel{padding-right:20px}.rst__rowLabel,.rst__rowToolbar{-webkit-box-flex:0;-ms-flex:0 1 auto;flex:0 1 auto}.rst__rowToolbar{display:-webkit-box;display:-ms-flexbox;display:flex}.rst__loadingHandle,.rst__moveHandle{height:100%;width:44px;background:#d9d9d9 url(\\\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0MiIgaGVpZ2h0PSI0MiI+PGcgc3Ryb2tlPSIjRkZGIiBzdHJva2Utd2lkdGg9IjIuOSIgPjxwYXRoIGQ9Ik0xNCAxNS43aDE0LjQiLz48cGF0aCBkPSJNMTQgMjEuNGgxNC40Ii8+PHBhdGggZD0iTTE0IDI3LjFoMTQuNCIvPjwvZz4KPC9zdmc+\\\") no-repeat 50%;border:1px solid #aaa;box-shadow:0 2px 2px -2px;cursor:move;border-radius:1px;z-index:1}.rst__loadingHandle{cursor:default;background:#d9d9d9}@-webkit-keyframes rst__pointFade{0%,19.999%,to{opacity:0}20%{opacity:1}}@keyframes rst__pointFade{0%,19.999%,to{opacity:0}20%{opacity:1}}.rst__loadingCircle{width:80%;height:80%;margin:10%;position:relative}.rst__loadingCirclePoint{width:100%;height:100%;position:absolute;left:0;top:0}.rst__loadingCirclePoint:before{content:\\\"\\\";display:block;margin:0 auto;width:11%;height:30%;background-color:#fff;border-radius:30%;-webkit-animation:rst__pointFade .8s infinite ease-in-out both;animation:rst__pointFade .8s infinite ease-in-out both}.rst__loadingCirclePoint:first-of-type{-webkit-transform:rotate(0deg);-ms-transform:rotate(0deg);transform:rotate(0deg)}.rst__loadingCirclePoint:first-of-type:before,.rst__loadingCirclePoint:nth-of-type(7):before{-webkit-animation-delay:-.8s;animation-delay:-.8s}.rst__loadingCirclePoint:nth-of-type(2){-webkit-transform:rotate(30deg);-ms-transform:rotate(30deg);transform:rotate(30deg)}.rst__loadingCirclePoint:nth-of-type(8){-webkit-transform:rotate(210deg);-ms-transform:rotate(210deg);transform:rotate(210deg)}.rst__loadingCirclePoint:nth-of-type(2):before,.rst__loadingCirclePoint:nth-of-type(8):before{-webkit-animation-delay:-666.66667ms;animation-delay:-666.66667ms}.rst__loadingCirclePoint:nth-of-type(3){-webkit-transform:rotate(60deg);-ms-transform:rotate(60deg);transform:rotate(60deg)}.rst__loadingCirclePoint:nth-of-type(9){-webkit-transform:rotate(240deg);-ms-transform:rotate(240deg);transform:rotate(240deg)}.rst__loadingCirclePoint:nth-of-type(3):before,.rst__loadingCirclePoint:nth-of-type(9):before{-webkit-animation-delay:-.53333333s;animation-delay:-.53333333s}.rst__loadingCirclePoint:nth-of-type(4){-webkit-transform:rotate(90deg);-ms-transform:rotate(90deg);transform:rotate(90deg)}.rst__loadingCirclePoint:nth-of-type(10){-webkit-transform:rotate(270deg);-ms-transform:rotate(270deg);transform:rotate(270deg)}.rst__loadingCirclePoint:nth-of-type(4):before,.rst__loadingCirclePoint:nth-of-type(10):before{-webkit-animation-delay:-.4s;animation-delay:-.4s}.rst__loadingCirclePoint:nth-of-type(5){-webkit-transform:rotate(120deg);-ms-transform:rotate(120deg);transform:rotate(120deg)}.rst__loadingCirclePoint:nth-of-type(11){-webkit-transform:rotate(300deg);-ms-transform:rotate(300deg);transform:rotate(300deg)}.rst__loadingCirclePoint:nth-of-type(5):before,.rst__loadingCirclePoint:nth-of-type(11):before{-webkit-animation-delay:-.26666667s;animation-delay:-.26666667s}.rst__loadingCirclePoint:nth-of-type(6){-webkit-transform:rotate(150deg);-ms-transform:rotate(150deg);transform:rotate(150deg)}.rst__loadingCirclePoint:nth-of-type(12){-webkit-transform:rotate(330deg);-ms-transform:rotate(330deg);transform:rotate(330deg)}.rst__loadingCirclePoint:nth-of-type(6):before,.rst__loadingCirclePoint:nth-of-type(12):before{-webkit-animation-delay:-.13333333s;animation-delay:-.13333333s}.rst__loadingCirclePoint:nth-of-type(7){-webkit-transform:rotate(180deg);-ms-transform:rotate(180deg);transform:rotate(180deg)}.rst__loadingCirclePoint:nth-of-type(13){-webkit-transform:rotate(1turn);-ms-transform:rotate(1turn);transform:rotate(1turn)}.rst__loadingCirclePoint:nth-of-type(7):before,.rst__loadingCirclePoint:nth-of-type(13):before{-webkit-animation-delay:0ms;animation-delay:0ms}.rst__rowTitle{font-weight:700}.rst__rowTitleWithSubtitle{font-size:85%;display:block;height:.8rem}.rst__rowSubtitle{font-size:70%;line-height:1}.rst__collapseButton,.rst__expandButton{-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;position:absolute;border-radius:100%;box-shadow:0 0 0 1px #000;width:16px;height:16px;top:50%;-webkit-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%);cursor:pointer}.rst__collapseButton:focus,.rst__expandButton:focus{outline:none;box-shadow:0 0 0 1px #000,0 0 1px 3px #83bef9}.rst__collapseButton:hover:not(:active),.rst__expandButton:hover:not(:active){background-size:24px;height:20px;width:20px}.rst__collapseButton{background:#fff url(\\\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOCIgaGVpZ2h0PSIxOCI+PGNpcmNsZSBjeD0iOSIgY3k9IjkiIHI9IjgiIGZpbGw9IiNGRkYiLz48ZyBzdHJva2U9IiM5ODk4OTgiIHN0cm9rZS13aWR0aD0iMS45IiA+PHBhdGggZD0iTTQuNSA5aDkiLz48L2c+Cjwvc3ZnPg==\\\") no-repeat 50%}.rst__expandButton{background:#fff url(\\\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOCIgaGVpZ2h0PSIxOCI+PGNpcmNsZSBjeD0iOSIgY3k9IjkiIHI9IjgiIGZpbGw9IiNGRkYiLz48ZyBzdHJva2U9IiM5ODk4OTgiIHN0cm9rZS13aWR0aD0iMS45IiA+PHBhdGggZD0iTTQuNSA5aDkiLz48cGF0aCBkPSJNOSA0LjV2OSIvPjwvZz4KPC9zdmc+\\\") no-repeat 50%}.rst__row_NoFlex:before,.rst__rowContents_NoFlex:before{content:\\\"\\\";display:inline-block;vertical-align:middle;height:100%}.rst__rowContents_NoFlex{display:inline-block}.rst__rowContents_NoFlex:after{content:\\\"\\\";display:inline-block;width:100%}.rst__rowLabel_NoFlex{width:50%}.rst__rowToolbar_NoFlex{text-align:right;width:50%}.rst__lineChildren{height:100%;display:inline-block;position:absolute}.rst__lineChildren:after{content:\\\"\\\";position:absolute;background-color:#000;width:1px;left:50%;bottom:0;height:10px}\", \"\"]);\n\t\n\t// exports\n\texports.locals = {\n\t\t\"rowWrapper\": \"rst__rowWrapper\",\n\t\t\"row\": \"rst__row\",\n\t\t\"rowLandingPad\": \"rst__rowLandingPad\",\n\t\t\"rowCancelPad\": \"rst__rowCancelPad\",\n\t\t\"rowSearchMatch\": \"rst__rowSearchMatch\",\n\t\t\"rowSearchFocus\": \"rst__rowSearchFocus\",\n\t\t\"rowContents\": \"rst__rowContents\",\n\t\t\"rowLabel\": \"rst__rowLabel\",\n\t\t\"rowToolbar\": \"rst__rowToolbar\",\n\t\t\"moveHandle\": \"rst__moveHandle\",\n\t\t\"loadingHandle\": \"rst__loadingHandle\",\n\t\t\"toolbarButton\": \"rst__toolbarButton\",\n\t\t\"rowLabel_NoFlex\": \"rst__rowLabel_NoFlex\",\n\t\t\"rowToolbar_NoFlex\": \"rst__rowToolbar_NoFlex\",\n\t\t\"rowContentsDragDisabled\": \"rst__rowContentsDragDisabled\",\n\t\t\"loadingCircle\": \"rst__loadingCircle\",\n\t\t\"loadingCirclePoint\": \"rst__loadingCirclePoint\",\n\t\t\"pointFade\": \"rst__pointFade\",\n\t\t\"rowTitle\": \"rst__rowTitle\",\n\t\t\"rowTitleWithSubtitle\": \"rst__rowTitleWithSubtitle\",\n\t\t\"rowSubtitle\": \"rst__rowSubtitle\",\n\t\t\"collapseButton\": \"rst__collapseButton\",\n\t\t\"expandButton\": \"rst__expandButton\",\n\t\t\"row_NoFlex\": \"rst__row_NoFlex\",\n\t\t\"rowContents_NoFlex\": \"rst__rowContents_NoFlex\",\n\t\t\"lineChildren\": \"rst__lineChildren\"\n\t};\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(2)(undefined);\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".rst__tree{/*! This comment keeps Sass from deleting the empty rule */}.rst__virtualScrollOverride{overflow:auto!important}.rst__virtualScrollOverride *{box-sizing:border-box}.ReactVirtualized__Grid__innerScrollContainer{overflow:visible!important}.ReactVirtualized__Grid{outline:none}\", \"\"]);\n\t\n\t// exports\n\texports.locals = {\n\t\t\"tree\": \"rst__tree\",\n\t\t\"virtualScrollOverride\": \"rst__virtualScrollOverride\"\n\t};\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(2)(undefined);\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".rst__node{min-width:100%;white-space:nowrap;position:relative}.rst__nodeContent{position:absolute;top:0;bottom:0}.rst__absoluteLineBlock,.rst__lineBlock{height:100%;position:relative;display:inline-block}.rst__absoluteLineBlock{position:absolute;top:0}.rst__lineFullVertical:after,.rst__lineHalfHorizontalRight:before,.rst__lineHalfVerticalBottom:after,.rst__lineHalfVerticalTop:after{position:absolute;content:\\\"\\\";background-color:#000}.rst__lineHalfHorizontalRight:before{height:1px;top:50%;right:0;width:50%}.rst__lineFullVertical:after,.rst__lineHalfVerticalBottom:after,.rst__lineHalfVerticalTop:after{width:1px;left:50%;top:0;height:100%}.rst__lineHalfVerticalBottom:after,.rst__lineHalfVerticalTop:after{top:0;height:50%}.rst__lineHalfVerticalBottom:after{top:auto;bottom:0}.rst__highlightLineVertical{z-index:3}.rst__highlightLineVertical:before{position:absolute;content:\\\"\\\";background-color:#36c2f6;width:8px;margin-left:-4px;left:50%;top:0;height:100%}@-webkit-keyframes rst__arrow-pulse{0%{-webkit-transform:translate(0);transform:translate(0);opacity:0}30%{-webkit-transform:translateY(300%);transform:translateY(300%);opacity:1}70%{-webkit-transform:translateY(700%);transform:translateY(700%);opacity:1}to{-webkit-transform:translateY(1000%);transform:translateY(1000%);opacity:0}}@keyframes rst__arrow-pulse{0%{-webkit-transform:translate(0);transform:translate(0);opacity:0}30%{-webkit-transform:translateY(300%);transform:translateY(300%);opacity:1}70%{-webkit-transform:translateY(700%);transform:translateY(700%);opacity:1}to{-webkit-transform:translateY(1000%);transform:translateY(1000%);opacity:0}}.rst__highlightLineVertical:after{content:\\\"\\\";position:absolute;height:0;margin-left:-4px;left:50%;top:0;border-left:4px solid transparent;border-right:4px solid transparent;border-top:4px solid #fff;-webkit-animation:rst__arrow-pulse 1s infinite linear both;animation:rst__arrow-pulse 1s infinite linear both}.rst__highlightTopLeftCorner:before{z-index:3;content:\\\"\\\";position:absolute;border-top:8px solid #36c2f6;border-left:8px solid #36c2f6;box-sizing:border-box;height:calc(50% + 4px);top:50%;margin-top:-4px;right:0;width:calc(50% + 4px)}.rst__highlightBottomLeftCorner{z-index:3}.rst__highlightBottomLeftCorner:before{content:\\\"\\\";position:absolute;border-bottom:8px solid #36c2f6;border-left:8px solid #36c2f6;box-sizing:border-box;height:calc(100% + 4px);top:0;right:12px;width:calc(50% - 8px)}.rst__highlightBottomLeftCorner:after{content:\\\"\\\";position:absolute;height:0;right:0;top:100%;margin-top:-12px;border-top:12px solid transparent;border-bottom:12px solid transparent;border-left:12px solid #36c2f6}\", \"\"]);\n\t\n\t// exports\n\texports.locals = {\n\t\t\"node\": \"rst__node\",\n\t\t\"nodeContent\": \"rst__nodeContent\",\n\t\t\"lineBlock\": \"rst__lineBlock\",\n\t\t\"absoluteLineBlock\": \"rst__absoluteLineBlock\",\n\t\t\"lineHalfHorizontalRight\": \"rst__lineHalfHorizontalRight\",\n\t\t\"lineFullVertical\": \"rst__lineFullVertical\",\n\t\t\"lineHalfVerticalTop\": \"rst__lineHalfVerticalTop\",\n\t\t\"lineHalfVerticalBottom\": \"rst__lineHalfVerticalBottom\",\n\t\t\"highlightLineVertical\": \"rst__highlightLineVertical\",\n\t\t\"arrow-pulse\": \"rst__arrow-pulse\",\n\t\t\"highlightTopLeftCorner\": \"rst__highlightTopLeftCorner\",\n\t\t\"highlightBottomLeftCorner\": \"rst__highlightBottomLeftCorner\"\n\t};\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(14);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(3)(content, {\"insertAt\":\"top\"});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!../css-loader/index.js?-autoprefixer!../postcss-loader/index.js!./styles.css\", function() {\n\t\t\t\tvar newContent = require(\"!!../css-loader/index.js?-autoprefixer!../postcss-loader/index.js!./styles.css\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(15);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(3)(content, {\"insertAt\":\"top\"});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!../node_modules/css-loader/index.js?modules&-autoprefixer&importLoaders=1&localIdentName=rst__[local]!../node_modules/postcss-loader/index.js!../node_modules/sass-loader/index.js!./node-renderer-default.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!../node_modules/css-loader/index.js?modules&-autoprefixer&importLoaders=1&localIdentName=rst__[local]!../node_modules/postcss-loader/index.js!../node_modules/sass-loader/index.js!./node-renderer-default.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(16);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(3)(content, {\"insertAt\":\"top\"});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!../node_modules/css-loader/index.js?modules&-autoprefixer&importLoaders=1&localIdentName=rst__[local]!../node_modules/postcss-loader/index.js!../node_modules/sass-loader/index.js!./react-sortable-tree.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!../node_modules/css-loader/index.js?modules&-autoprefixer&importLoaders=1&localIdentName=rst__[local]!../node_modules/postcss-loader/index.js!../node_modules/sass-loader/index.js!./react-sortable-tree.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(17);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(3)(content, {\"insertAt\":\"top\"});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!../node_modules/css-loader/index.js?modules&-autoprefixer&importLoaders=1&localIdentName=rst__[local]!../node_modules/postcss-loader/index.js!../node_modules/sass-loader/index.js!./tree-node.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!../node_modules/css-loader/index.js?modules&-autoprefixer&importLoaders=1&localIdentName=rst__[local]!../node_modules/postcss-loader/index.js!../node_modules/sass-loader/index.js!./tree-node.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_22__;\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_23__;\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_24__;\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_25__;\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_26__;\n\n/***/ })\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// react-sortable-tree.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap ad000d290dee929048c1","import SortableTree, { SortableTreeWithoutDndContext } from './react-sortable-tree';\r\n\r\nexport * from './utils/default-handlers';\r\nexport * from './utils/tree-data-utils';\r\nexport default SortableTree;\r\n\r\n// Export the tree component without the react-dnd DragDropContext,\r\n// for when component is used with other components using react-dnd.\r\n// see: https://github.com/gaearon/react-dnd/issues/186\r\nexport { SortableTreeWithoutDndContext };\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","/**\r\n * Performs a depth-first traversal over all of the node descendants,\r\n * incrementing currentIndex by 1 for each\r\n */\r\nfunction getNodeDataAtTreeIndexOrNextIndex({\r\n    targetIndex,\r\n    node,\r\n    currentIndex,\r\n    getNodeKey,\r\n    path = [],\r\n    lowerSiblingCounts = [],\r\n    ignoreCollapsed = true,\r\n    isPseudoRoot = false,\r\n}) {\r\n    // The pseudo-root is not considered in the path\r\n    const selfPath = !isPseudoRoot ? [...path, getNodeKey({ node, treeIndex: currentIndex })] : [];\r\n\r\n    // Return target node when found\r\n    if (currentIndex === targetIndex) {\r\n        return {\r\n            node,\r\n            lowerSiblingCounts,\r\n            path: selfPath,\r\n        };\r\n    }\r\n\r\n    // Add one and continue for nodes with no children or hidden children\r\n    if (!node.children || (ignoreCollapsed && node.expanded !== true)) {\r\n        return { nextIndex: currentIndex + 1 };\r\n    }\r\n\r\n    // Iterate over each child and their descendants and return the\r\n    // target node if childIndex reaches the targetIndex\r\n    let childIndex   = currentIndex + 1;\r\n    const childCount = node.children.length;\r\n    for (let i = 0; i < childCount; i++) {\r\n        const result = getNodeDataAtTreeIndexOrNextIndex({\r\n            ignoreCollapsed,\r\n            getNodeKey,\r\n            targetIndex,\r\n            node: node.children[i],\r\n            currentIndex: childIndex,\r\n            lowerSiblingCounts: [ ...lowerSiblingCounts, childCount - i - 1 ],\r\n            path: selfPath,\r\n        });\r\n\r\n        if (result.node) {\r\n            return result;\r\n        }\r\n\r\n        childIndex = result.nextIndex;\r\n    }\r\n\r\n    // If the target node is not found, return the farthest traversed index\r\n    return { nextIndex: childIndex };\r\n}\r\n\r\nexport function getDescendantCount({ node, ignoreCollapsed = true }) {\r\n    return getNodeDataAtTreeIndexOrNextIndex({\r\n        getNodeKey: () => {},\r\n        ignoreCollapsed,\r\n        node,\r\n        currentIndex: 0,\r\n        targetIndex:  -1,\r\n    }).nextIndex - 1;\r\n}\r\n\r\n/**\r\n * Walk all descendants of the given node, depth-first\r\n *\r\n * @param {Object} args - Function parameters\r\n * @param {function} args.callback - Function to call on each node\r\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\r\n *                                        as the parent of all the nodes in the tree\r\n * @param {Object} args.node - A tree node\r\n * @param {Object=} args.parentNode - The parent node of `node`\r\n * @param {number} args.currentIndex - The treeIndex of `node`\r\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\r\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\r\n *                                             previous nodes in this path\r\n *\r\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\r\n *                                    or false if the walk should be terminated\r\n */\r\nfunction walkDescendants({\r\n    callback,\r\n    getNodeKey,\r\n    ignoreCollapsed,\r\n    isPseudoRoot = false,\r\n    node,\r\n    parentNode = null,\r\n    currentIndex,\r\n    path = [],\r\n    lowerSiblingCounts = [],\r\n}) {\r\n    // The pseudo-root is not considered in the path\r\n    const selfPath = isPseudoRoot ? [] : [\r\n        ...path,\r\n        getNodeKey({ node, treeIndex: currentIndex }),\r\n    ];\r\n    const selfInfo = isPseudoRoot ? null : {\r\n        node,\r\n        parentNode,\r\n        path: selfPath,\r\n        lowerSiblingCounts,\r\n        treeIndex: currentIndex,\r\n    };\r\n\r\n    if (!isPseudoRoot) {\r\n        const callbackResult = callback(selfInfo);\r\n\r\n        // Cut walk short if the callback returned false\r\n        if (callbackResult === false) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Return self on nodes with no children or hidden children\r\n    if (!node.children || (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)) {\r\n        return currentIndex;\r\n    }\r\n\r\n    // Get all descendants\r\n    let childIndex   = currentIndex;\r\n    const childCount = node.children.length;\r\n    if (typeof node.children !== 'function') {\r\n        for (let i = 0; i < childCount; i++) {\r\n            childIndex = walkDescendants({\r\n                callback,\r\n                getNodeKey,\r\n                ignoreCollapsed,\r\n                node: node.children[i],\r\n                parentNode: isPseudoRoot ? null : node,\r\n                currentIndex: childIndex + 1,\r\n                lowerSiblingCounts: [ ...lowerSiblingCounts, childCount - i - 1 ],\r\n                path: selfPath,\r\n            });\r\n\r\n            // Cut walk short if the callback returned false\r\n            if (childIndex === false) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return childIndex;\r\n}\r\n\r\n/**\r\n * Perform a change on the given node and all its descendants, traversing the tree depth-first\r\n *\r\n * @param {Object} args - Function parameters\r\n * @param {function} args.callback - Function to call on each node\r\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\r\n *                                        as the parent of all the nodes in the tree\r\n * @param {Object} args.node - A tree node\r\n * @param {Object=} args.parentNode - The parent node of `node`\r\n * @param {number} args.currentIndex - The treeIndex of `node`\r\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\r\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\r\n *                                             previous nodes in this path\r\n *\r\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\r\n *                                    or false if the walk should be terminated\r\n */\r\nfunction mapDescendants({\r\n    callback,\r\n    getNodeKey,\r\n    ignoreCollapsed,\r\n    isPseudoRoot = false,\r\n    node,\r\n    parentNode = null,\r\n    currentIndex,\r\n    path = [],\r\n    lowerSiblingCounts = [],\r\n}) {\r\n    const nextNode = { ...node };\r\n\r\n    // The pseudo-root is not considered in the path\r\n    const selfPath = isPseudoRoot ? [] : [\r\n        ...path,\r\n        getNodeKey({ node: nextNode, treeIndex: currentIndex }),\r\n    ];\r\n    const selfInfo = {\r\n        node: nextNode,\r\n        parentNode,\r\n        path: selfPath,\r\n        lowerSiblingCounts,\r\n        treeIndex: currentIndex,\r\n    };\r\n\r\n    // Return self on nodes with no children or hidden children\r\n    if (!nextNode.children || (nextNode.expanded !== true && ignoreCollapsed && !isPseudoRoot)) {\r\n        return {\r\n            treeIndex: currentIndex,\r\n            node: callback(selfInfo),\r\n        };\r\n    }\r\n\r\n    // Get all descendants\r\n    let childIndex   = currentIndex;\r\n    const childCount = nextNode.children.length;\r\n    if (typeof nextNode.children !== 'function') {\r\n        nextNode.children = nextNode.children.map((child, i) => {\r\n            const mapResult = mapDescendants({\r\n                callback,\r\n                getNodeKey,\r\n                ignoreCollapsed,\r\n                node: child,\r\n                parentNode: isPseudoRoot ? null : nextNode,\r\n                currentIndex: childIndex + 1,\r\n                lowerSiblingCounts: [ ...lowerSiblingCounts, childCount - i - 1 ],\r\n                path: selfPath,\r\n            });\r\n            childIndex = mapResult.treeIndex;\r\n\r\n            return mapResult.node;\r\n        });\r\n    }\r\n\r\n    return {\r\n        node: callback(selfInfo),\r\n        treeIndex: childIndex,\r\n    };\r\n}\r\n\r\n/**\r\n * Count all the visible (expanded) descendants in the tree data.\r\n *\r\n * @param {!Object[]} treeData - Tree data\r\n *\r\n * @return {number} count\r\n */\r\nexport function getVisibleNodeCount({ treeData }) {\r\n    const traverse = (node) => {\r\n        if (!node.children || node.expanded !== true || (typeof node.children === 'function')) {\r\n            return 1;\r\n        }\r\n\r\n        return 1 + node.children.reduce((total, currentNode) => (total + traverse(currentNode)), 0);\r\n    };\r\n\r\n    return treeData.reduce((total, currentNode) => total + traverse(currentNode), 0);\r\n}\r\n\r\n/**\r\n * Get the <targetIndex>th visible node in the tree data.\r\n *\r\n * @param {!Object[]} treeData - Tree data\r\n * @param {!number} targetIndex - The index of the node to search for\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n *\r\n * @return {{\r\n *      node: Object,\r\n *      path: []string|[]number,\r\n *      lowerSiblingCounts: []number\r\n *  }|null} node - The node at targetIndex, or null if not found\r\n */\r\nexport function getVisibleNodeInfoAtIndex({ treeData, index: targetIndex, getNodeKey }) {\r\n    if (!treeData || treeData.length < 1) {\r\n        return null;\r\n    }\r\n\r\n    // Call the tree traversal with a pseudo-root node\r\n    const result = getNodeDataAtTreeIndexOrNextIndex({\r\n        targetIndex,\r\n        getNodeKey,\r\n        node: {\r\n            children: treeData,\r\n            expanded: true,\r\n        },\r\n        currentIndex: -1,\r\n        path: [],\r\n        lowerSiblingCounts: [],\r\n        isPseudoRoot: true,\r\n    });\r\n\r\n    if (result.node) {\r\n        return result;\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Walk descendants depth-first and call a callback on each\r\n *\r\n * @param {!Object[]} treeData - Tree data\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {function} callback - Function to call on each node\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n *\r\n * @return void\r\n */\r\nexport function walk({ treeData, getNodeKey, callback, ignoreCollapsed = true }) {\r\n    if (!treeData || treeData.length < 1) {\r\n        return;\r\n    }\r\n\r\n    return walkDescendants({\r\n        callback,\r\n        getNodeKey,\r\n        ignoreCollapsed,\r\n        isPseudoRoot: true,\r\n        node: { children: treeData },\r\n        currentIndex: -1,\r\n        path: [],\r\n        lowerSiblingCounts: [],\r\n    });\r\n}\r\n\r\n/**\r\n * Perform a depth-first transversal of the descendants and\r\n *  make a change to every node in the tree\r\n *\r\n * @param {!Object[]} treeData - Tree data\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {function} callback - Function to call on each node\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n *\r\n * @return {Object[]} changedTreeData - The changed tree data\r\n */\r\nexport function map({ treeData, getNodeKey, callback, ignoreCollapsed = true }) {\r\n    if (!treeData || treeData.length < 1) {\r\n        return [];\r\n    }\r\n\r\n    return mapDescendants({\r\n        callback,\r\n        getNodeKey,\r\n        ignoreCollapsed,\r\n        isPseudoRoot: true,\r\n        node: { children: treeData },\r\n        currentIndex: -1,\r\n        path: [],\r\n        lowerSiblingCounts: [],\r\n    }).node.children;\r\n}\r\n\r\n/**\r\n * Expand or close every node in the tree\r\n *\r\n * @param {!Object[]} treeData - Tree data\r\n * @param {?boolean} expanded - Whether the node is expanded or not\r\n *\r\n * @return {Object[]} changedTreeData - The changed tree data\r\n */\r\nexport function toggleExpandedForAll({ treeData, expanded = true }) {\r\n    return map({\r\n        treeData,\r\n        callback: ({ node }) => ({ ...node, expanded }),\r\n        getNodeKey: ({ treeIndex }) => treeIndex,\r\n        ignoreCollapsed: false,\r\n    });\r\n}\r\n\r\n/**\r\n * Replaces node at path with object, or callback-defined object\r\n *\r\n * @param {!Object[]} treeData\r\n * @param {number[]|string[]} path - Array of keys leading up to node to be changed\r\n * @param {function|any} newNode - Node to replace the node at the path with, or a function producing the new node\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n *\r\n * @return {Object[]} changedTreeData - The changed tree data\r\n */\r\nexport function changeNodeAtPath({ treeData, path, newNode, getNodeKey, ignoreCollapsed = true }) {\r\n    const RESULT_MISS = 'RESULT_MISS';\r\n    const traverse = ({\r\n        isPseudoRoot = false,\r\n        node,\r\n        currentTreeIndex,\r\n        pathIndex,\r\n    }) => {\r\n        if (!isPseudoRoot && getNodeKey({ node, treeIndex: currentTreeIndex }) !== path[pathIndex]) {\r\n            return RESULT_MISS;\r\n        }\r\n\r\n        if (pathIndex >= path.length - 1) {\r\n            // If this is the final location in the path, return its changed form\r\n            return typeof newNode === 'function' ? newNode({ node, treeIndex: currentTreeIndex }) : newNode;\r\n        } else if (!node.children) {\r\n            // If this node is part of the path, but has no children, return the unchanged node\r\n            throw new Error('Path referenced children of node with no children.');\r\n        }\r\n\r\n        let nextTreeIndex = currentTreeIndex + 1;\r\n        for (let i = 0; i < node.children.length; i++) {\r\n            const result = traverse({\r\n                node:             node.children[i],\r\n                currentTreeIndex: nextTreeIndex,\r\n                pathIndex:        pathIndex + 1,\r\n            });\r\n\r\n            // If the result went down the correct path\r\n            if (result !== RESULT_MISS) {\r\n                if (result) {\r\n                    // If the result was truthy (in this case, an object),\r\n                    //  pass it to the next level of recursion up\r\n                    return {\r\n                        ...node,\r\n                        children: [\r\n                            ...node.children.slice(0, i),\r\n                            result,\r\n                            ...node.children.slice(i + 1),\r\n                        ],\r\n                    };\r\n                }\r\n                // If the result was falsy (returned from the newNode function), then\r\n                //  delete the node from the array.\r\n                return {\r\n                    ...node,\r\n                    children: [\r\n                        ...node.children.slice(0, i),\r\n                        ...node.children.slice(i + 1),\r\n                    ],\r\n                };\r\n            }\r\n\r\n            nextTreeIndex += 1 + getDescendantCount({ node: node.children[i], ignoreCollapsed });\r\n        }\r\n\r\n        return RESULT_MISS;\r\n    };\r\n\r\n    // Use a pseudo-root node in the beginning traversal\r\n    const result = traverse({\r\n        node: { children: treeData },\r\n        currentTreeIndex: -1,\r\n        pathIndex: -1,\r\n        isPseudoRoot: true,\r\n    });\r\n\r\n    if (result === RESULT_MISS) {\r\n        throw new Error('No node found at the given path.');\r\n    }\r\n\r\n    return result.children;\r\n}\r\n\r\n/**\r\n * Removes the node at the specified path and returns the resulting treeData.\r\n *\r\n * @param {!Object[]} treeData\r\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n *\r\n * @return {Object[]} changedTreeData - The tree data with the node removed\r\n */\r\nexport function removeNodeAtPath({ treeData, path, getNodeKey, ignoreCollapsed = true }) {\r\n    return changeNodeAtPath({\r\n        treeData,\r\n        path,\r\n        getNodeKey,\r\n        ignoreCollapsed,\r\n        newNode: null, // Delete the node\r\n    });\r\n}\r\n\r\n/**\r\n * Gets the node at the specified path\r\n *\r\n * @param {!Object[]} treeData\r\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n *\r\n * @return {Object|null} nodeInfo - The node info at the given path, or null if not found\r\n */\r\nexport function getNodeAtPath({ treeData, path, getNodeKey, ignoreCollapsed = true }) {\r\n    let foundNodeInfo = null;\r\n\r\n    try {\r\n        changeNodeAtPath({\r\n            treeData,\r\n            path,\r\n            getNodeKey,\r\n            ignoreCollapsed,\r\n            newNode: ({ node, treeIndex }) => {\r\n                foundNodeInfo = { node, treeIndex };\r\n                return node;\r\n            },\r\n        });\r\n    } catch (err) {\r\n        // Ignore the error -- the null return will be explanation enough\r\n    }\r\n\r\n    return foundNodeInfo;\r\n}\r\n\r\n/**\r\n * Adds the node to the specified parent and returns the resulting treeData.\r\n *\r\n * @param {!Object[]} treeData\r\n * @param {!Object} newNode - The node to insert\r\n * @param {number|string} parentKey - The key of the to-be parentNode of the node\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n * @param {boolean=} expandParent - If true, expands the parentNode specified by parentPath\r\n *\r\n * @return {Object} result\r\n * @return {Object[]} result.treeData - The updated tree data\r\n * @return {number} result.treeIndex - The tree index at which the node was inserted\r\n */\r\nexport function addNodeUnderParent({\r\n    treeData,\r\n    newNode,\r\n    parentKey = null,\r\n    getNodeKey,\r\n    ignoreCollapsed = true,\r\n    expandParent = false,\r\n}) {\r\n    if (parentKey === null) {\r\n        return {\r\n            treeData: [ ...(treeData || []), newNode],\r\n            treeIndex: (treeData || []).length,\r\n        };\r\n    }\r\n\r\n    let insertedTreeIndex = null;\r\n    let hasBeenAdded = false;\r\n    const changedTreeData = map({\r\n        treeData,\r\n        getNodeKey,\r\n        ignoreCollapsed,\r\n        callback: ({ node, treeIndex, path }) => {\r\n            const key = path ? path[path.length - 1] : null;\r\n            // Return nodes that are not the parent as-is\r\n            if (hasBeenAdded || key !== parentKey) {\r\n                return node;\r\n            }\r\n            hasBeenAdded = true;\r\n\r\n            const parentNode = {\r\n                ...node,\r\n            };\r\n\r\n            if (expandParent) {\r\n                parentNode.expanded = true;\r\n            }\r\n\r\n            // If no children exist yet, just add the single newNode\r\n            if (!parentNode.children) {\r\n                insertedTreeIndex = treeIndex + 1;\r\n                return {\r\n                    ...parentNode,\r\n                    children: [ newNode ],\r\n                };\r\n            }\r\n\r\n            if (typeof parentNode.children === 'function') {\r\n                throw new Error('Cannot add to children defined by a function');\r\n            }\r\n\r\n            let nextTreeIndex = treeIndex + 1;\r\n            for (let i = 0; i < parentNode.children.length; i++) {\r\n                nextTreeIndex += 1 + getDescendantCount({ node: parentNode.children[i], ignoreCollapsed });\r\n            }\r\n\r\n            insertedTreeIndex = nextTreeIndex;\r\n\r\n            return {\r\n                ...parentNode,\r\n                children: [ ...parentNode.children, newNode ],\r\n            };\r\n        },\r\n    });\r\n\r\n    if (!hasBeenAdded) {\r\n        throw new Error('No node found with the given key.');\r\n    }\r\n\r\n    return {\r\n        treeData: changedTreeData,\r\n        treeIndex: insertedTreeIndex,\r\n    };\r\n}\r\n\r\nfunction addNodeAtDepthAndIndex({\r\n    targetDepth,\r\n    minimumTreeIndex,\r\n    newNode,\r\n    ignoreCollapsed,\r\n    expandParent,\r\n    isPseudoRoot = false,\r\n    isLastChild,\r\n    node,\r\n    currentIndex,\r\n    currentDepth,\r\n    getNodeKey,\r\n    path = [],\r\n}) {\r\n    const selfPath = n => (isPseudoRoot ? [] : [\r\n        ...path,\r\n        getNodeKey({ node: n, treeIndex: currentIndex }),\r\n    ]);\r\n\r\n    // If the current position is the only possible place to add, add it\r\n    if (currentIndex >= minimumTreeIndex - 1\r\n      || (isLastChild && !(node.children && node.children.length))) {\r\n        if (typeof node.children === 'function') {\r\n            throw new Error('Cannot add to children defined by a function');\r\n        } else {\r\n            const extraNodeProps = expandParent ? { expanded: true } : {};\r\n            const nextNode = {\r\n                ...node,\r\n\r\n                ...extraNodeProps,\r\n                children: node.children ? [newNode, ...node.children] : [newNode],\r\n            };\r\n\r\n            return {\r\n                node: nextNode,\r\n                nextIndex: currentIndex + 2,\r\n                insertedTreeIndex: currentIndex + 1,\r\n                parentPath: selfPath(nextNode),\r\n                parentNode: isPseudoRoot ? null : nextNode,\r\n            };\r\n        }\r\n    }\r\n\r\n    // If this is the target depth for the insertion,\r\n    // i.e., where the newNode can be added to the current node's children\r\n    if (currentDepth >= targetDepth - 1) {\r\n        // Skip over nodes with no children or hidden children\r\n        if (!node.children ||\r\n            typeof node.children === 'function' ||\r\n            (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\r\n        ) {\r\n            return { node, nextIndex: currentIndex + 1 };\r\n        }\r\n\r\n        // Scan over the children to see if there's a place among them that fulfills\r\n        // the minimumTreeIndex requirement\r\n        let childIndex        = currentIndex + 1;\r\n        let insertedTreeIndex = null;\r\n        let insertIndex       = null;\r\n        for (let i = 0; i < node.children.length; i++) {\r\n            // If a valid location is found, mark it as the insertion location and\r\n            // break out of the loop\r\n            if (childIndex >= minimumTreeIndex) {\r\n                insertedTreeIndex = childIndex;\r\n                insertIndex = i;\r\n                break;\r\n            }\r\n\r\n            // Increment the index by the child itself plus the number of descendants it has\r\n            childIndex += 1 + getDescendantCount({ node: node.children[i], ignoreCollapsed });\r\n        }\r\n\r\n        // If no valid indices to add the node were found\r\n        if (insertIndex === null) {\r\n            // If the last position in this node's children is less than the minimum index\r\n            // and there are more children on the level of this node, return without insertion\r\n            if (childIndex < minimumTreeIndex && !isLastChild) {\r\n                return { node, nextIndex: childIndex };\r\n            }\r\n\r\n            // Use the last position in the children array to insert the newNode\r\n            insertedTreeIndex = childIndex;\r\n            insertIndex = node.children.length;\r\n        }\r\n\r\n        // Insert the newNode at the insertIndex\r\n        const nextNode = {\r\n            ...node,\r\n            children: [\r\n                ...node.children.slice(0, insertIndex),\r\n                newNode,\r\n                ...node.children.slice(insertIndex),\r\n            ],\r\n        };\r\n\r\n        // Return node with successful insert result\r\n        return {\r\n            node: nextNode,\r\n            nextIndex: childIndex,\r\n            insertedTreeIndex,\r\n            parentPath: selfPath(nextNode),\r\n            parentNode: isPseudoRoot ? null : nextNode,\r\n        };\r\n    }\r\n\r\n    // Skip over nodes with no children or hidden children\r\n    if (!node.children ||\r\n        typeof node.children === 'function' ||\r\n        (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\r\n    ) {\r\n        return { node, nextIndex: currentIndex + 1 };\r\n    }\r\n\r\n    // Get all descendants\r\n    let insertedTreeIndex = null;\r\n    let pathFragment      = null;\r\n    let parentNode        = null;\r\n    let childIndex        = currentIndex + 1;\r\n    let newChildren       = node.children;\r\n    if (typeof newChildren !== 'function') {\r\n        newChildren = newChildren.map((child, i) => {\r\n            if (insertedTreeIndex !== null) {\r\n                return child;\r\n            }\r\n\r\n            const mapResult = addNodeAtDepthAndIndex({\r\n                targetDepth,\r\n                minimumTreeIndex,\r\n                newNode,\r\n                ignoreCollapsed,\r\n                expandParent,\r\n                isLastChild: isLastChild && i === newChildren.length - 1,\r\n                node: child,\r\n                currentIndex: childIndex,\r\n                currentDepth: currentDepth + 1,\r\n                getNodeKey,\r\n                path: [], // Cannot determine the parent path until the children have been processed\r\n            });\r\n\r\n            if ('insertedTreeIndex' in mapResult) {\r\n                insertedTreeIndex = mapResult.insertedTreeIndex;\r\n                pathFragment      = mapResult.parentPath;\r\n                parentNode        = mapResult.parentNode;\r\n            }\r\n\r\n            childIndex = mapResult.nextIndex;\r\n\r\n            return mapResult.node;\r\n        });\r\n    }\r\n\r\n    const nextNode = { ...node, children: newChildren };\r\n    const result = {\r\n        node: nextNode,\r\n        nextIndex: childIndex,\r\n    };\r\n\r\n    if (insertedTreeIndex !== null) {\r\n        result.insertedTreeIndex = insertedTreeIndex;\r\n        result.parentPath        = [ ...selfPath(nextNode), ...pathFragment ];\r\n        result.parentNode        = parentNode;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Insert a node into the tree at the given depth, after the minimum index\r\n *\r\n * @param {!Object[]} treeData - Tree data\r\n * @param {!number} depth - The depth to insert the node at (the first level of the array being depth 0)\r\n * @param {!number} minimumTreeIndex - The lowest possible treeIndex to insert the node at\r\n * @param {!Object} newNode - The node to insert into the tree\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n * @param {boolean=} expandParent - If true, expands the parent of the inserted node\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n *\r\n * @return {Object} result\r\n * @return {Object[]} result.treeData - The tree data with the node added\r\n * @return {number} result.treeIndex - The tree index at which the node was inserted\r\n * @return {number[]|string[]} result.path - Array of keys leading to the node location after insertion\r\n * @return {Object} result.parentNode - The parent node of the inserted node\r\n */\r\nexport function insertNode({\r\n    treeData,\r\n    depth: targetDepth,\r\n    minimumTreeIndex,\r\n    newNode,\r\n    getNodeKey = () => {},\r\n    ignoreCollapsed = true,\r\n    expandParent = false,\r\n}) {\r\n    if (!treeData && targetDepth === 0) {\r\n        return {\r\n            treeData:   [newNode],\r\n            treeIndex:  0,\r\n            path:       [getNodeKey({ node: newNode, treeIndex: 0 })],\r\n            parentNode: null,\r\n        };\r\n    }\r\n\r\n    const insertResult = addNodeAtDepthAndIndex({\r\n        targetDepth,\r\n        minimumTreeIndex,\r\n        newNode,\r\n        ignoreCollapsed,\r\n        expandParent,\r\n        getNodeKey,\r\n        isPseudoRoot: true,\r\n        isLastChild: true,\r\n        node: { children: treeData },\r\n        currentIndex: -1,\r\n        currentDepth: -1,\r\n    });\r\n\r\n    if (!('insertedTreeIndex' in insertResult)) {\r\n        throw new Error('No suitable position found to insert.');\r\n    }\r\n\r\n    const treeIndex = insertResult.insertedTreeIndex;\r\n    return {\r\n        treeData: insertResult.node.children,\r\n        treeIndex,\r\n        path:     [ ...insertResult.parentPath, getNodeKey({ node: newNode, treeIndex }) ],\r\n        parentNode: insertResult.parentNode,\r\n    };\r\n}\r\n\r\n/**\r\n * Get tree data flattened.\r\n *\r\n * @param {!Object[]} treeData - Tree data\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n *\r\n * @return {{\r\n *      node: Object,\r\n *      path: []string|[]number,\r\n *      lowerSiblingCounts: []number\r\n *  }}[] nodes - The node array\r\n */\r\nexport function getFlatDataFromTree({ treeData, getNodeKey, ignoreCollapsed = true }) {\r\n    if (!treeData || treeData.length < 1) {\r\n        return [];\r\n    }\r\n\r\n    const flattened = [];\r\n    walk({\r\n        treeData,\r\n        getNodeKey,\r\n        ignoreCollapsed,\r\n        callback: (nodeInfo) => {\r\n            flattened.push(nodeInfo);\r\n        },\r\n    });\r\n\r\n    return flattened;\r\n}\r\n\r\n/**\r\n * Generate a tree structure from flat data.\r\n *\r\n * @param {!Object[]} flatData\r\n * @param {!function=} getKey - Function to get the key from the nodeData\r\n * @param {!function=} getParentKey - Function to get the parent key from the nodeData\r\n * @param {string|number=} rootKey - The value returned by `getParentKey` that corresponds to the root node.\r\n *                                  For example, if your nodes have id 1-99, you might use rootKey = 0\r\n *\r\n * @return {Object[]} treeData - The flat data represented as a tree\r\n */\r\nexport function getTreeFromFlatData({\r\n    flatData,\r\n    getKey = (node => node.id),\r\n    getParentKey = (node => node.parentId),\r\n    rootKey = '0',\r\n}) {\r\n    if (!flatData) {\r\n        return [];\r\n    }\r\n\r\n    const childrenToParents = {};\r\n    flatData.forEach((child) => {\r\n        const parentKey = getParentKey(child);\r\n\r\n        if (parentKey in childrenToParents) {\r\n            childrenToParents[parentKey].push(child);\r\n        } else {\r\n            childrenToParents[parentKey] = [ child ];\r\n        }\r\n    });\r\n\r\n    if (!(rootKey in childrenToParents)) {\r\n        return [];\r\n    }\r\n\r\n    const trav = (parent) => {\r\n        const parentKey = getKey(parent);\r\n        if (parentKey in childrenToParents) {\r\n            return {\r\n                ...parent,\r\n                children: childrenToParents[parentKey].map(child => trav(child)),\r\n            };\r\n        }\r\n\r\n        return { ...parent };\r\n    };\r\n\r\n    return childrenToParents[rootKey].map(child => trav(child));\r\n}\r\n\r\n/**\r\n * Check if a node is a descendant of another node.\r\n *\r\n * @param {!Object} older - Potential ancestor of younger node\r\n * @param {!Object} younger - Potential descendant of older node\r\n *\r\n * @return {boolean}\r\n */\r\nexport function isDescendant(older, younger) {\r\n    return !!older.children && typeof older.children !== 'function' &&\r\n        older.children.some(child => (child === younger || isDescendant(child, younger)));\r\n}\r\n\r\n/**\r\n * Get the maximum depth of the children (the depth of the root node is 0).\r\n *\r\n * @param {!Object} node - Node in the tree\r\n * @param {?number} depth - The current depth\r\n *\r\n * @return {number} maxDepth - The deepest depth in the tree\r\n */\r\nexport function getDepth(node, depth = 0) {\r\n    if (!node.children) {\r\n        return depth;\r\n    }\r\n\r\n    if (typeof node.children === 'function') {\r\n        return depth + 1;\r\n    }\r\n\r\n    return node.children.reduce(\r\n        (deepest, child) => Math.max(deepest, getDepth(child, depth + 1)),\r\n        depth\r\n    );\r\n}\r\n\r\n/**\r\n * Find nodes matching a search query in the tree,\r\n *\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {!Object[]} treeData - Tree data\r\n * @param {?string|number} searchQuery - Function returning a boolean to indicate whether the node is a match or not\r\n * @param {!function} searchMethod - Function returning a boolean to indicate whether the node is a match or not\r\n * @param {?number} searchFocusOffset - The offset of the match to focus on\r\n *                                      (e.g., 0 focuses on the first match, 1 on the second)\r\n * @param {boolean=} expandAllMatchPaths - If true, expands the paths to any matched node\r\n * @param {boolean=} expandFocusMatchPaths - If true, expands the path to the focused node\r\n *\r\n * @return {Object[]} matches - An array of objects containing the matching `node`s, their `path`s and `treeIndex`s\r\n * @return {Object[]} treeData - The original tree data with all relevant nodes expanded.\r\n *                               If expandAllMatchPaths and expandFocusMatchPaths are both false,\r\n *                               it will be the same as the original tree data.\r\n */\r\nexport function find({\r\n    getNodeKey,\r\n    treeData,\r\n    searchQuery,\r\n    searchMethod,\r\n    searchFocusOffset,\r\n    expandAllMatchPaths = false,\r\n    expandFocusMatchPaths = true,\r\n}) {\r\n    let matchCount = 0;\r\n    const trav = ({\r\n        isPseudoRoot = false,\r\n        node,\r\n        currentIndex,\r\n        path = [],\r\n    }) => {\r\n        let matches = [];\r\n        let isSelfMatch = false;\r\n        let hasFocusMatch = false;\r\n        // The pseudo-root is not considered in the path\r\n        const selfPath = isPseudoRoot ? [] : [\r\n            ...path,\r\n            getNodeKey({ node, treeIndex: currentIndex }),\r\n        ];\r\n        const extraInfo = isPseudoRoot ? null : {\r\n            path: selfPath,\r\n            treeIndex: currentIndex,\r\n        };\r\n\r\n        // Nodes with with children that aren't lazy\r\n        const hasChildren = node.children &&\r\n            typeof node.children !== 'function' &&\r\n            node.children.length > 0;\r\n\r\n        // Examine the current node to see if it is a match\r\n        if (!isPseudoRoot && searchMethod({ ...extraInfo, node, searchQuery })) {\r\n            if (matchCount === searchFocusOffset) {\r\n                hasFocusMatch = true;\r\n            }\r\n\r\n            // Keep track of the number of matching nodes, so we know when the searchFocusOffset\r\n            //  is reached\r\n            matchCount++;\r\n\r\n            // We cannot add this node to the matches right away, as it may be changed\r\n            //  during the search of the descendants. The entire node is used in\r\n            //  comparisons between nodes inside the `matches` and `treeData` results\r\n            //  of this method (`find`)\r\n            isSelfMatch = true;\r\n        }\r\n\r\n        let childIndex = currentIndex;\r\n        const newNode = { ...node };\r\n        if (hasChildren) {\r\n            // Get all descendants\r\n            newNode.children = newNode.children.map((child) => {\r\n                const mapResult = trav({\r\n                    node: child,\r\n                    currentIndex: childIndex + 1,\r\n                    path: selfPath,\r\n                });\r\n\r\n                // Ignore hidden nodes by only advancing the index counter to the returned treeIndex\r\n                // if the child is expanded.\r\n                //\r\n                // The child could have been expanded from the start,\r\n                // or expanded due to a matching node being found in its descendants\r\n                if (mapResult.node.expanded) {\r\n                    childIndex = mapResult.treeIndex;\r\n                } else {\r\n                    childIndex += 1;\r\n                }\r\n\r\n                if (mapResult.matches.length > 0 || mapResult.hasFocusMatch) {\r\n                    matches = [ ...matches, ...mapResult.matches ];\r\n                    if (mapResult.hasFocusMatch) {\r\n                        hasFocusMatch = true;\r\n                    }\r\n\r\n                    // Expand the current node if it has descendants matching the search\r\n                    // and the settings are set to do so.\r\n                    if ((expandAllMatchPaths && mapResult.matches.length > 0) ||\r\n                        ((expandAllMatchPaths || expandFocusMatchPaths) && mapResult.hasFocusMatch)\r\n                    ) {\r\n                        newNode.expanded = true;\r\n                    }\r\n                }\r\n\r\n                return mapResult.node;\r\n            });\r\n        }\r\n\r\n        // Cannot assign a treeIndex to hidden nodes\r\n        if (!isPseudoRoot && !newNode.expanded) {\r\n            matches = matches.map(match => ({\r\n                ...match,\r\n                treeIndex: null,\r\n            }));\r\n        }\r\n\r\n        // Add this node to the matches if it fits the search criteria.\r\n        // This is performed at the last minute so newNode can be sent in its final form.\r\n        if (isSelfMatch) {\r\n            matches = [\r\n                { ...extraInfo, node: newNode },\r\n                ...matches,\r\n            ];\r\n        }\r\n\r\n        return {\r\n            node: matches.length > 0 ? newNode : node,\r\n            matches,\r\n            hasFocusMatch,\r\n            treeIndex: childIndex,\r\n        };\r\n    };\r\n\r\n    const result = trav({\r\n        node: { children: treeData },\r\n        isPseudoRoot: true,\r\n        currentIndex: -1,\r\n    });\r\n\r\n    return {\r\n        matches: result.matches,\r\n        treeData: result.node.children,\r\n    };\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/tree-data-utils.js","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader/lib/css-base.js\n// module id = 2\n// module chunks = 0","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nvar stylesInDom = {},\n\tmemoize = function(fn) {\n\t\tvar memo;\n\t\treturn function () {\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\treturn memo;\n\t\t};\n\t},\n\tisOldIE = memoize(function() {\n\t\treturn /msie [6-9]\\b/.test(self.navigator.userAgent.toLowerCase());\n\t}),\n\tgetHeadElement = memoize(function () {\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t}),\n\tsingletonElement = null,\n\tsingletonCounter = 0,\n\tstyleElementsInsertedAtTop = [];\n\nmodule.exports = function(list, options) {\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the bottom of <head>.\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list);\n\taddStylesToDom(styles, options);\n\n\treturn function update(newList) {\n\t\tvar mayRemove = [];\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction addStylesToDom(styles, options) {\n\tfor(var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles(list) {\n\tvar styles = [];\n\tvar newStyles = {};\n\tfor(var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\tif(!newStyles[id])\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse\n\t\t\tnewStyles[id].parts.push(part);\n\t}\n\treturn styles;\n}\n\nfunction insertStyleElement(options, styleElement) {\n\tvar head = getHeadElement();\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\tif (options.insertAt === \"top\") {\n\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\thead.appendChild(styleElement);\n\t\t}\n\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t} else if (options.insertAt === \"bottom\") {\n\t\thead.appendChild(styleElement);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement(styleElement) {\n\tstyleElement.parentNode.removeChild(styleElement);\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\tif(idx >= 0) {\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement(options) {\n\tvar styleElement = document.createElement(\"style\");\n\tstyleElement.type = \"text/css\";\n\tinsertStyleElement(options, styleElement);\n\treturn styleElement;\n}\n\nfunction createLinkElement(options) {\n\tvar linkElement = document.createElement(\"link\");\n\tlinkElement.rel = \"stylesheet\";\n\tinsertStyleElement(options, linkElement);\n\treturn linkElement;\n}\n\nfunction addStyle(obj, options) {\n\tvar styleElement, update, remove;\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t} else if(obj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\") {\n\t\tstyleElement = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t\tif(styleElement.href)\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\n\t\t};\n\t} else {\n\t\tstyleElement = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle(newObj) {\n\t\tif(newObj) {\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\treturn;\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = styleElement.childNodes;\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\tif (childNodes.length) {\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyleElement.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag(styleElement, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyleElement.setAttribute(\"media\", media)\n\t}\n\n\tif(styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = css;\n\t} else {\n\t\twhile(styleElement.firstChild) {\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t}\n\t\tstyleElement.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink(linkElement, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\tif(sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = linkElement.href;\n\n\tlinkElement.href = URL.createObjectURL(blob);\n\n\tif(oldSrc)\n\t\tURL.revokeObjectURL(oldSrc);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/style-loader/addStyles.js\n// module id = 3\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"prop-types\"\n// module id = 4\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"react\"\n// module id = 5\n// module chunks = 0","export function defaultGetNodeKey({ node: _node, treeIndex }) {\r\n    return treeIndex;\r\n}\r\n\r\n// Cheap hack to get the text of a react object\r\nfunction getReactElementText(parent) {\r\n    if (typeof parent === 'string') {\r\n        return parent;\r\n    }\r\n\r\n    if (typeof parent !== 'object' ||\r\n        !parent.props ||\r\n        !parent.props.children ||\r\n        (typeof parent.props.children !== 'string' && typeof parent.props.children !== 'object')\r\n    ) {\r\n        return '';\r\n    }\r\n\r\n    if (typeof parent.props.children === 'string') {\r\n        return parent.props.children;\r\n    }\r\n\r\n    return parent.props.children.map(child => getReactElementText(child)).join('');\r\n}\r\n\r\n// Search for a query string inside a node property\r\nfunction stringSearch(key, searchQuery, node, path, treeIndex) {\r\n    if (typeof node[key] === 'function') {\r\n        return String(node[key]({ node, path, treeIndex })).indexOf(searchQuery) > -1;\r\n    } else if (typeof node[key] === 'object') {\r\n        return getReactElementText(node[key]).indexOf(searchQuery) > -1;\r\n    }\r\n\r\n    return node[key] && String(node[key]).indexOf(searchQuery) > -1;\r\n}\r\n\r\nexport function defaultSearchMethod({ node, path, treeIndex, searchQuery }) {\r\n    return stringSearch('title', searchQuery, node, path, treeIndex) ||\r\n        stringSearch('subtitle', searchQuery, node, path, treeIndex);\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/default-handlers.js","import { insertNode } from './tree-data-utils';\r\n\r\nlet memoizedInsertArgsArray = [];\r\nlet memoizedInsertKeysArray = [];\r\nlet memoizedInsertResult    = null;\r\n\r\n/**\r\n * Insert a node into the tree at the given depth, after the minimum index\r\n *\r\n * @param {!Object[]} treeData - Tree data\r\n * @param {!number} depth - The depth to insert the node at (the first level of the array being depth 0)\r\n * @param {!number} minimumTreeIndex - The lowest possible treeIndex to insert the node at\r\n * @param {!Object} newNode - The node to insert into the tree\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n * @param {boolean=} expandParent - If true, expands the parent of the inserted node\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n *\r\n * @return {Object} result\r\n * @return {Object[]} result.treeData - The tree data with the node added\r\n * @return {number} result.treeIndex - The tree index at which the node was inserted\r\n * @return {number[]|string[]} result.path - Array of keys leading to the node location after insertion\r\n */\r\nexport function memoizedInsertNode(args) {\r\n    const keysArray = Object.keys(args).sort();\r\n    const argsArray = keysArray.map(key => args[key]);\r\n\r\n    // If the arguments for the last insert operation are different than this time,\r\n    // recalculate the result\r\n    if (argsArray.length !== memoizedInsertArgsArray.length ||\r\n        argsArray.some((arg, index) => arg !== memoizedInsertArgsArray[index]) ||\r\n        keysArray.some((key, index) => key !== memoizedInsertKeysArray[index])\r\n    ) {\r\n        memoizedInsertArgsArray = argsArray;\r\n        memoizedInsertKeysArray = keysArray;\r\n        memoizedInsertResult    = insertNode(args);\r\n    }\r\n\r\n    return memoizedInsertResult;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/memoized-tree-data-utils.js","import React, { Component } from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport { getIEVersion } from './utils/browser-utils';\r\nimport baseStyles from './node-renderer-default.scss';\r\nimport { isDescendant } from './utils/tree-data-utils';\r\n\r\nlet styles = baseStyles;\r\n// Add extra classes in browsers that don't support flex\r\nif (getIEVersion < 10) {\r\n    styles = {\r\n        ...baseStyles,\r\n        row:         `${styles.row} ${styles.row_NoFlex}`,\r\n        rowContents: `${styles.rowContents} ${styles.rowContents_NoFlex}`,\r\n        rowLabel:    `${styles.rowLabel} ${styles.rowLabel_NoFlex}`,\r\n        rowToolbar:  `${styles.rowToolbar} ${styles.rowToolbar_NoFlex}`,\r\n    };\r\n}\r\n\r\nclass NodeRendererDefault extends Component {\r\n    render() {\r\n        const {\r\n            scaffoldBlockPxWidth,\r\n            toggleChildrenVisibility,\r\n            connectDragPreview,\r\n            connectDragSource,\r\n            isDragging,\r\n            canDrop,\r\n            canDrag,\r\n            node,\r\n            draggedNode,\r\n            path,\r\n            treeIndex,\r\n            isSearchMatch,\r\n            isSearchFocus,\r\n            buttons,\r\n            className,\r\n            style = {},\r\n            didDrop,\r\n            isOver:     _isOver,     // Not needed, but preserved for other renderers\r\n            parentNode: _parentNode, // Needed for drag-and-drop utils\r\n            endDrag:    _endDrag,    // Needed for drag-and-drop utils\r\n            startDrag:  _startDrag,  // Needed for drag-and-drop utils\r\n            ...otherProps,\r\n        } = this.props;\r\n\r\n        let handle;\r\n        if (canDrag) {\r\n            if (typeof node.children === 'function' && node.expanded) {\r\n                // Show a loading symbol on the handle when the children are expanded\r\n                //  and yet still defined by a function (a callback to fetch the children)\r\n                handle = (\r\n                    <div className={styles.loadingHandle}>\r\n                        <div className={styles.loadingCircle}>\r\n                            <div className={styles.loadingCirclePoint} />\r\n                            <div className={styles.loadingCirclePoint} />\r\n                            <div className={styles.loadingCirclePoint} />\r\n                            <div className={styles.loadingCirclePoint} />\r\n                            <div className={styles.loadingCirclePoint} />\r\n                            <div className={styles.loadingCirclePoint} />\r\n                            <div className={styles.loadingCirclePoint} />\r\n                            <div className={styles.loadingCirclePoint} />\r\n                            <div className={styles.loadingCirclePoint} />\r\n                            <div className={styles.loadingCirclePoint} />\r\n                            <div className={styles.loadingCirclePoint} />\r\n                            <div className={styles.loadingCirclePoint} />\r\n                        </div>\r\n                    </div>\r\n                );\r\n            } else {\r\n                // Show the handle used to initiate a drag-and-drop\r\n                handle = connectDragSource((\r\n                    <div className={styles.moveHandle} />\r\n                ), { dropEffect: 'copy' });\r\n            }\r\n        }\r\n\r\n        const isDraggedDescendant = draggedNode && isDescendant(draggedNode, node);\r\n        const isLandingPadActive  = !didDrop && isDragging;\r\n\r\n        return (\r\n            <div\r\n                style={{ height: '100%' }}\r\n                {...otherProps}\r\n            >\r\n                {toggleChildrenVisibility && node.children && node.children.length > 0 && (\r\n                    <div>\r\n                        <button\r\n                            type=\"button\"\r\n                            aria-label={node.expanded ? 'Collapse' : 'Expand'}\r\n                            className={node.expanded ? styles.collapseButton : styles.expandButton}\r\n                            style={{ left: -0.5 * scaffoldBlockPxWidth }}\r\n                            onClick={() => toggleChildrenVisibility({node, path, treeIndex})}\r\n                        />\r\n\r\n                        {node.expanded && !isDragging &&\r\n                            <div\r\n                                style={{ width: scaffoldBlockPxWidth }}\r\n                                className={styles.lineChildren}\r\n                            />\r\n                        }\r\n                    </div>\r\n                )}\r\n\r\n                <div className={styles.rowWrapper}>\r\n                    {/* Set the row preview to be used during drag and drop */}\r\n                    {connectDragPreview(\r\n                        <div\r\n                            className={styles.row +\r\n                                (isLandingPadActive ? ` ${styles.rowLandingPad}` : '') +\r\n                                (isLandingPadActive && !canDrop ? ` ${styles.rowCancelPad}` : '') +\r\n                                (isSearchMatch ? ` ${styles.rowSearchMatch}` : '') +\r\n                                (isSearchFocus ? ` ${styles.rowSearchFocus}` : '') +\r\n                                (className ? ` ${className}` : '')\r\n                            }\r\n                            style={{\r\n                                opacity: isDraggedDescendant ? 0.5 : 1,\r\n                                ...style,\r\n                            }}\r\n                        >\r\n                            {handle}\r\n\r\n                            <div\r\n                                className={styles.rowContents +\r\n                                    (!canDrag ? ` ${styles.rowContentsDragDisabled}` : '')\r\n                                }\r\n                            >\r\n                                <div className={styles.rowLabel}>\r\n                                    <span\r\n                                        className={styles.rowTitle +\r\n                                            (node.subtitle ? ` ${styles.rowTitleWithSubtitle}` : '')\r\n                                        }\r\n                                    >\r\n                                        {typeof node.title === 'function' ?\r\n                                            node.title({node, path, treeIndex }) :\r\n                                            node.title\r\n                                        }\r\n                                    </span>\r\n\r\n                                    {node.subtitle &&\r\n                                        <span className={styles.rowSubtitle}>\r\n                                            {typeof node.subtitle === 'function' ?\r\n                                                node.subtitle({node, path, treeIndex }) :\r\n                                                node.subtitle\r\n                                            }\r\n                                        </span>\r\n                                    }\r\n                                </div>\r\n\r\n                                <div className={styles.rowToolbar}>\r\n                                    {buttons && buttons.map((btn, index) => (\r\n                                        <div key={index} className={styles.toolbarButton}>\r\n                                            {btn}\r\n                                        </div>\r\n                                    ))}\r\n                                </div>\r\n                            </div>\r\n                        </div>\r\n                    )}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nNodeRendererDefault.propTypes = {\r\n    node: PropTypes.object.isRequired,\r\n    path: PropTypes.arrayOf(PropTypes.oneOfType([ PropTypes.string, PropTypes.number ])).isRequired,\r\n    treeIndex: PropTypes.number.isRequired,\r\n    isSearchMatch: PropTypes.bool,\r\n    isSearchFocus: PropTypes.bool,\r\n    canDrag: PropTypes.bool,\r\n    scaffoldBlockPxWidth: PropTypes.number.isRequired,\r\n    toggleChildrenVisibility: PropTypes.func,\r\n    buttons: PropTypes.arrayOf(PropTypes.node),\r\n    className: PropTypes.string,\r\n    style: PropTypes.object,\r\n\r\n    // Drag and drop API functions\r\n    // Drag source\r\n    connectDragPreview: PropTypes.func.isRequired,\r\n    connectDragSource:  PropTypes.func.isRequired,\r\n    parentNode:         PropTypes.object,          // Needed for drag-and-drop utils\r\n    startDrag:          PropTypes.func.isRequired, // Needed for drag-and-drop utils\r\n    endDrag:            PropTypes.func.isRequired, // Needed for drag-and-drop utils\r\n    isDragging:         PropTypes.bool.isRequired,\r\n    didDrop:            PropTypes.bool.isRequired,\r\n    draggedNode:        PropTypes.object,\r\n    // Drop target\r\n    isOver:  PropTypes.bool.isRequired,\r\n    canDrop: PropTypes.bool,\r\n};\r\n\r\nexport default NodeRendererDefault;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-renderer-default.js","/*!\r\n * react-sortable-tree\r\n * Copyright 2016 Chris Fritz All rights reserved.\r\n * @license Open source under the MIT License\r\n */\r\n\r\nimport React, { Component } from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport { AutoSizer, List } from 'react-virtualized';\r\nimport isEqual from 'lodash.isequal';\r\nimport withScrolling, { createVerticalStrength, createHorizontalStrength } from 'react-dnd-scrollzone';\r\nimport 'react-virtualized/styles.css';\r\nimport TreeNode from './tree-node';\r\nimport NodeRendererDefault from './node-renderer-default';\r\nimport {\r\n    walk,\r\n    getFlatDataFromTree,\r\n    changeNodeAtPath,\r\n    removeNodeAtPath,\r\n    insertNode,\r\n    getDescendantCount,\r\n    find,\r\n} from './utils/tree-data-utils';\r\nimport {\r\n    memoizedInsertNode,\r\n} from './utils/memoized-tree-data-utils';\r\nimport {\r\n    swapRows,\r\n} from './utils/generic-utils';\r\nimport {\r\n    defaultGetNodeKey,\r\n    defaultSearchMethod,\r\n} from './utils/default-handlers';\r\nimport {\r\n    dndWrapRoot,\r\n    dndWrapSource,\r\n    dndWrapTarget,\r\n} from './utils/drag-and-drop-utils';\r\nimport styles from './react-sortable-tree.scss';\r\n\r\nlet dndTypeCounter = 1;\r\n\r\nclass ReactSortableTree extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        const {\r\n            dndType,\r\n            nodeContentRenderer,\r\n            isVirtualized,\r\n            slideRegionSize,\r\n            treeData,\r\n        } = props;\r\n\r\n        // Wrapping classes for use with react-dnd\r\n        this.dndType             = dndType || `rst__${dndTypeCounter++}`;\r\n        this.nodeContentRenderer = dndWrapSource(nodeContentRenderer, this.dndType);\r\n        this.treeNodeRenderer    = dndWrapTarget(TreeNode, this.dndType);\r\n\r\n        // Prepare scroll-on-drag options for this list\r\n        if (isVirtualized) {\r\n            this.scrollZoneVirtualList = withScrolling(List);\r\n            this.vStrength             = createVerticalStrength(slideRegionSize);\r\n            this.hStrength             = createHorizontalStrength(slideRegionSize);\r\n        }\r\n\r\n        this.state = {\r\n            draggingTreeData: null,\r\n            swapFrom: null,\r\n            swapLength: null,\r\n            swapDepth: null,\r\n            rows: this.getRows(treeData),\r\n            searchMatches: [],\r\n            searchFocusTreeIndex: null,\r\n        };\r\n\r\n        this.toggleChildrenVisibility = this.toggleChildrenVisibility.bind(this);\r\n        this.moveNode                 = this.moveNode.bind(this);\r\n        this.startDrag                = this.startDrag.bind(this);\r\n        this.dragHover                = this.dragHover.bind(this);\r\n        this.endDrag                  = this.endDrag.bind(this);\r\n    }\r\n\r\n    componentWillMount() {\r\n        this.loadLazyChildren();\r\n        this.search(this.props, false, false);\r\n        this.ignoreOneTreeUpdate = false;\r\n    }\r\n\r\n    toggleChildrenVisibility({ node: targetNode, path, treeIndex: _treeIndex }) {\r\n        const treeData = changeNodeAtPath({\r\n            treeData: this.props.treeData,\r\n            path,\r\n            newNode: ({ node }) => ({ ...node, expanded: !node.expanded }),\r\n            getNodeKey: this.props.getNodeKey,\r\n        });\r\n\r\n        this.props.onChange(treeData);\r\n\r\n        if (this.props.onVisibilityToggle) {\r\n            this.props.onVisibilityToggle({\r\n                treeData,\r\n                node: targetNode,\r\n                expanded: !targetNode.expanded,\r\n            });\r\n        }\r\n    }\r\n\r\n    moveNode({ node, depth, minimumTreeIndex }) {\r\n        const {\r\n            treeData,\r\n            treeIndex,\r\n            path,\r\n        } = insertNode({\r\n            treeData: this.state.draggingTreeData,\r\n            newNode: node,\r\n            depth,\r\n            minimumTreeIndex,\r\n            expandParent: true,\r\n            getNodeKey: this.props.getNodeKey,\r\n        });\r\n\r\n        this.props.onChange(treeData);\r\n\r\n        if (this.props.onMoveNode) {\r\n            this.props.onMoveNode({ treeData, node, treeIndex, path });\r\n        }\r\n    }\r\n\r\n    componentWillReceiveProps(nextProps) {\r\n        this.setState({ searchFocusTreeIndex: null });\r\n        if (this.props.treeData !== nextProps.treeData) {\r\n            // Ignore updates caused by search, in order to avoid infinite looping\r\n            if (this.ignoreOneTreeUpdate) {\r\n                this.ignoreOneTreeUpdate = false;\r\n            } else {\r\n                this.loadLazyChildren(nextProps);\r\n                // Load any children defined by a function\r\n                this.search(nextProps, false, false);\r\n            }\r\n\r\n            // Calculate the rows to be shown from the new tree data\r\n            this.setState({\r\n                draggingTreeData: null,\r\n                swapFrom: null,\r\n                swapLength: null,\r\n                swapDepth: null,\r\n                rows: this.getRows(nextProps.treeData),\r\n            });\r\n        } else if (!isEqual(this.props.searchQuery, nextProps.searchQuery)) {\r\n            this.search(nextProps);\r\n        } else if (this.props.searchFocusOffset !== nextProps.searchFocusOffset) {\r\n            this.search(nextProps, true, true, true);\r\n        }\r\n    }\r\n\r\n    getRows(treeData) {\r\n        return getFlatDataFromTree({\r\n            ignoreCollapsed: true,\r\n            getNodeKey: this.props.getNodeKey,\r\n            treeData,\r\n        });\r\n    }\r\n\r\n    search(props = this.props, seekIndex = true, expand = true, singleSearch = false) {\r\n        const {\r\n            treeData,\r\n            onChange,\r\n            searchFinishCallback,\r\n            searchQuery,\r\n            searchMethod,\r\n            searchFocusOffset,\r\n        } = props;\r\n\r\n        // Skip search if no conditions are specified\r\n        if ((searchQuery === null || typeof searchQuery === 'undefined' || String(searchQuery) === '') &&\r\n            !searchMethod\r\n        ) {\r\n            this.setState({\r\n                searchMatches: [],\r\n            });\r\n\r\n            if (searchFinishCallback) {\r\n                searchFinishCallback([]);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        const {\r\n            treeData: expandedTreeData,\r\n            matches: searchMatches,\r\n        } = find({\r\n            getNodeKey: this.props.getNodeKey,\r\n            treeData,\r\n            searchQuery,\r\n            searchMethod: searchMethod || defaultSearchMethod,\r\n            searchFocusOffset,\r\n            expandAllMatchPaths: expand && !singleSearch,\r\n            expandFocusMatchPaths: expand && true,\r\n        });\r\n\r\n        // Update the tree with data leaving all paths leading to matching nodes open\r\n        if (expand) {\r\n            this.ignoreOneTreeUpdate = true; // Prevents infinite loop\r\n            onChange(expandedTreeData);\r\n        }\r\n\r\n        if (searchFinishCallback) {\r\n            searchFinishCallback(searchMatches);\r\n        }\r\n\r\n        let searchFocusTreeIndex = null;\r\n        if (seekIndex &&\r\n            searchFocusOffset !== null &&\r\n            searchFocusOffset < searchMatches.length\r\n        ) {\r\n            searchFocusTreeIndex = searchMatches[searchFocusOffset].treeIndex;\r\n        }\r\n\r\n        this.setState({\r\n            searchMatches,\r\n            searchFocusTreeIndex,\r\n        });\r\n    }\r\n\r\n    startDrag({ path }) {\r\n        if (this.props.freeze) return;\r\n        const draggingTreeData = removeNodeAtPath({\r\n            treeData: this.props.treeData,\r\n            path,\r\n            getNodeKey: this.props.getNodeKey,\r\n        });\r\n\r\n        this.setState({\r\n            draggingTreeData,\r\n        });\r\n    }\r\n\r\n    dragHover({ node: draggedNode, depth, minimumTreeIndex }) {\r\n        if (this.props.freeze) return;\r\n        const addedResult = memoizedInsertNode({\r\n            treeData: this.state.draggingTreeData,\r\n            newNode: draggedNode,\r\n            depth,\r\n            minimumTreeIndex,\r\n            expandParent: true,\r\n            getNodeKey: this.props.getNodeKey,\r\n        });\r\n\r\n        const rows               = this.getRows(addedResult.treeData);\r\n        const expandedParentPath = rows[addedResult.treeIndex].path;\r\n\r\n        const swapFrom   = addedResult.treeIndex;\r\n        const swapTo     = minimumTreeIndex;\r\n        const swapLength = 1 + getDescendantCount({ node: draggedNode });\r\n        this.setState({\r\n            rows: swapRows(rows, swapFrom, swapTo, swapLength),\r\n            swapFrom,\r\n            swapLength,\r\n            swapDepth: depth,\r\n            draggingTreeData: changeNodeAtPath({\r\n                treeData: this.state.draggingTreeData,\r\n                path: expandedParentPath.slice(0, -1),\r\n                newNode: ({ node }) => ({ ...node, expanded: true }),\r\n                getNodeKey: this.props.getNodeKey,\r\n            }),\r\n        });\r\n    }\r\n\r\n    endDrag(dropResult) {\r\n        if (this.props.freeze) return;\r\n        if (!dropResult || !dropResult.node) {\r\n            return this.setState({\r\n                draggingTreeData: null,\r\n                swapFrom: null,\r\n                swapLength: null,\r\n                swapDepth: null,\r\n                rows: this.getRows(this.props.treeData),\r\n            });\r\n        }\r\n\r\n        this.moveNode(dropResult);\r\n    }\r\n\r\n    /**\r\n     * Load any children in the tree that are given by a function\r\n     */\r\n    loadLazyChildren(props = this.props) {\r\n        walk({\r\n            treeData: props.treeData,\r\n            getNodeKey: this.props.getNodeKey,\r\n            callback: ({ node, path, lowerSiblingCounts, treeIndex }) => {\r\n                // If the node has children defined by a function, and is either expanded\r\n                //  or set to load even before expansion, run the function.\r\n                if (node.children &&\r\n                    typeof node.children === 'function' &&\r\n                    (node.expanded || props.loadCollapsedLazyChildren)\r\n                ) {\r\n                    // Call the children fetching function\r\n                    node.children({\r\n                        node,\r\n                        path,\r\n                        lowerSiblingCounts,\r\n                        treeIndex,\r\n\r\n                        // Provide a helper to append the new data when it is received\r\n                        done: childrenArray => this.props.onChange(changeNodeAtPath({\r\n                            treeData: this.props.treeData,\r\n                            path,\r\n                            newNode: ({ node: oldNode }) => (\r\n                                // Only replace the old node if it's the one we set off to find children\r\n                                //  for in the first place\r\n                                oldNode === node ? { ...oldNode, children: childrenArray } : oldNode\r\n                            ),\r\n                            getNodeKey: this.props.getNodeKey,\r\n                        })),\r\n                    });\r\n                }\r\n            },\r\n        });\r\n    }\r\n\r\n    render() {\r\n        const {\r\n            style,\r\n            className,\r\n            innerStyle,\r\n            rowHeight,\r\n            getNodeKey,\r\n            isVirtualized,\r\n        } = this.props;\r\n        const {\r\n            rows,\r\n            searchMatches,\r\n            searchFocusTreeIndex,\r\n        } = this.state;\r\n\r\n        // Get indices for rows that match the search conditions\r\n        const matchKeys = {};\r\n        searchMatches.forEach(({ path }, i) => { matchKeys[path[path.length - 1]] = i; });\r\n\r\n        // Seek to the focused search result if there is one specified\r\n        const scrollToInfo = searchFocusTreeIndex !== null ? { scrollToIndex: searchFocusTreeIndex } : {};\r\n\r\n        let containerStyle = style;\r\n        let list;\r\n        if (isVirtualized) {\r\n            containerStyle = { height: '100%', ...containerStyle  };\r\n\r\n            const ScrollZoneVirtualList = this.scrollZoneVirtualList;\r\n            // Render list with react-virtualized\r\n            list = (\r\n                <AutoSizer>\r\n                    {({height, width}) => (\r\n                        <ScrollZoneVirtualList\r\n                            {...scrollToInfo}\r\n                            verticalStrength={this.vStrength}\r\n                            horizontalStrength={this.hStrength}\r\n                            speed={30}\r\n                            scrollToAlignment=\"start\"\r\n                            className={styles.virtualScrollOverride}\r\n                            width={width}\r\n                            onScroll={({ scrollTop }) => { this.scrollTop = scrollTop; }}\r\n                            height={height}\r\n                            style={innerStyle}\r\n                            rowCount={rows.length}\r\n                            estimatedRowSize={typeof rowHeight !== 'function' ? rowHeight : undefined}\r\n                            rowHeight={rowHeight}\r\n                            rowRenderer={({ index, key, style: rowStyle }) => this.renderRow(\r\n                                rows[index],\r\n                                index,\r\n                                key,\r\n                                rowStyle,\r\n                                () => (rows[index - 1] || null),\r\n                                matchKeys\r\n                            )}\r\n                            {...this.props.reactVirtualizedListProps}\r\n                        />\r\n                    )}\r\n                </AutoSizer>\r\n            );\r\n        } else {\r\n            // Render list without react-virtualized\r\n            list = rows.map((row, index) => this.renderRow(\r\n                row,\r\n                index,\r\n                getNodeKey({\r\n                    node:      row.node,\r\n                    treeIndex: row.treeIndex,\r\n                }),\r\n                { height: typeof rowHeight !== 'function' ? rowHeight : rowHeight({ index }) },\r\n                () => (rows[index - 1] || null),\r\n                matchKeys\r\n            ));\r\n        }\r\n\r\n        return (\r\n            <div\r\n                className={styles.tree + (className ? ` ${className}` : '')}\r\n                style={containerStyle}\r\n            >\r\n                {list}\r\n            </div>\r\n        );\r\n    }\r\n\r\n    renderRow(\r\n        { node, parentNode, path, lowerSiblingCounts, treeIndex },\r\n        listIndex,\r\n        key,\r\n        style,\r\n        getPrevRow,\r\n        matchKeys\r\n    ) {\r\n        const {\r\n            canDrag,\r\n            canDrop,\r\n            generateNodeProps,\r\n            getNodeKey,\r\n            maxDepth,\r\n            scaffoldBlockPxWidth,\r\n            searchFocusOffset,\r\n            freeze,\r\n        } = this.props;\r\n        const TreeNodeRenderer    = this.treeNodeRenderer;\r\n        const NodeContentRenderer = this.nodeContentRenderer;\r\n        const nodeKey = path[path.length - 1];\r\n        const isSearchMatch = nodeKey in matchKeys;\r\n        const isSearchFocus = isSearchMatch && matchKeys[nodeKey] === searchFocusOffset;\r\n        const callbackParams = {\r\n            node,\r\n            parentNode,\r\n            path,\r\n            lowerSiblingCounts,\r\n            treeIndex,\r\n            isSearchMatch,\r\n            isSearchFocus,\r\n        };\r\n        const nodeProps = !generateNodeProps ? {} : generateNodeProps(callbackParams);\r\n        const rowCanDrag = typeof canDrag !== 'function' ? canDrag : canDrag(callbackParams);\r\n\r\n        return (\r\n            <TreeNodeRenderer\r\n                style={style}\r\n                key={key}\r\n                treeIndex={treeIndex}\r\n                listIndex={listIndex}\r\n                getPrevRow={getPrevRow}\r\n                treeData={this.state.draggingTreeData || this.state.treeData}\r\n                getNodeKey={getNodeKey}\r\n                customCanDrop={canDrop}\r\n                node={node}\r\n                path={path}\r\n                lowerSiblingCounts={lowerSiblingCounts}\r\n                scaffoldBlockPxWidth={scaffoldBlockPxWidth}\r\n                swapFrom={this.state.swapFrom}\r\n                swapLength={this.state.swapLength}\r\n                swapDepth={this.state.swapDepth}\r\n                maxDepth={maxDepth}\r\n                dragHover={this.dragHover}\r\n            >\r\n                <NodeContentRenderer\r\n                    node={node}\r\n                    parentNode={parentNode}\r\n                    path={path}\r\n                    isSearchMatch={isSearchMatch}\r\n                    isSearchFocus={isSearchFocus}\r\n                    treeIndex={treeIndex}\r\n                    startDrag={this.startDrag}\r\n                    endDrag={this.endDrag}\r\n                    canDrag={rowCanDrag}\r\n                    toggleChildrenVisibility={this.toggleChildrenVisibility}\r\n                    scaffoldBlockPxWidth={scaffoldBlockPxWidth}\r\n                    freeze={freeze}\r\n                    {...nodeProps}\r\n                />\r\n            </TreeNodeRenderer>\r\n        );\r\n    }\r\n}\r\n\r\nReactSortableTree.propTypes = {\r\n    // Tree data in the following format:\r\n    // [{title: 'main', subtitle: 'sub'}, { title: 'value2', expanded: true, children: [{ title: 'value3') }] }]\r\n    // `title` is the primary label for the node\r\n    // `subtitle` is a secondary label for the node\r\n    // `expanded` shows children of the node if true, or hides them if false. Defaults to false.\r\n    // `children` is an array of child nodes belonging to the node.\r\n    treeData: PropTypes.arrayOf(PropTypes.object).isRequired,\r\n\r\n    // Style applied to the container wrapping the tree (style defaults to {height: '100%'})\r\n    style: PropTypes.object,\r\n\r\n    // Class name for the container wrapping the tree\r\n    className: PropTypes.string,\r\n\r\n    // Style applied to the inner, scrollable container (for padding, etc.)\r\n    innerStyle: PropTypes.object,\r\n\r\n    // Used by react-virtualized\r\n    // Either a fixed row height (number) or a function that returns the\r\n    // height of a row given its index: `({ index: number }): number`\r\n    rowHeight: PropTypes.oneOfType([ PropTypes.number, PropTypes.func ]),\r\n\r\n    // Size in px of the region near the edges that initiates scrolling on dragover\r\n    slideRegionSize: PropTypes.number.isRequired, // eslint-disable-line react/no-unused-prop-types\r\n\r\n    // Custom properties to hand to the react-virtualized list\r\n    // https://github.com/bvaughn/react-virtualized/blob/master/docs/List.md#prop-types\r\n    reactVirtualizedListProps: PropTypes.object,\r\n\r\n    // The width of the blocks containing the lines representing the structure of the tree.\r\n    scaffoldBlockPxWidth: PropTypes.number,\r\n\r\n    // Maximum depth nodes can be inserted at. Defaults to infinite.\r\n    maxDepth: PropTypes.number,\r\n\r\n    // The method used to search nodes.\r\n    // Defaults to a function that uses the `searchQuery` string to search for nodes with\r\n    // matching `title` or `subtitle` values.\r\n    // NOTE: Changing `searchMethod` will not update the search, but changing the `searchQuery` will.\r\n    searchMethod: PropTypes.func, // eslint-disable-line react/no-unused-prop-types\r\n\r\n    // Used by the `searchMethod` to highlight and scroll to matched nodes.\r\n    // Should be a string for the default `searchMethod`, but can be anything when using a custom search.\r\n    searchQuery: PropTypes.any,\r\n\r\n    // Outline the <`searchFocusOffset`>th node and scroll to it.\r\n    searchFocusOffset: PropTypes.number,\r\n\r\n    // Get the nodes that match the search criteria. Used for counting total matches, etc.\r\n    searchFinishCallback: PropTypes.func, // eslint-disable-line react/no-unused-prop-types\r\n\r\n    // Generate an object with additional props to be passed to the node renderer.\r\n    // Use this for adding buttons via the `buttons` key,\r\n    // or additional `style` / `className` settings.\r\n    generateNodeProps: PropTypes.func,\r\n\r\n    // Set to false to disable virtualization.\r\n    // NOTE: Auto-scrolling while dragging, and scrolling to the `searchFocusOffset` will be disabled.\r\n    isVirtualized: PropTypes.bool,\r\n\r\n    // Override the default component for rendering nodes (but keep the scaffolding generator)\r\n    // This is an advanced option for complete customization of the appearance.\r\n    // It is best to copy the component in `node-renderer-default.js` to use as a base, and customize as needed.\r\n    nodeContentRenderer: PropTypes.any,\r\n\r\n    // Determine the unique key used to identify each node and\r\n    // generate the `path` array passed in callbacks.\r\n    // By default, returns the index in the tree (omitting hidden nodes).\r\n    getNodeKey: PropTypes.func,\r\n\r\n    // Called whenever tree data changed.\r\n    // Just like with React input elements, you have to update your\r\n    // own component's data to see the changes reflected.\r\n    onChange: PropTypes.func.isRequired,\r\n\r\n    // Called after node move operation.\r\n    onMoveNode: PropTypes.func,\r\n\r\n    // Determine whether a node can be dragged. Set to false to disable dragging on all nodes.\r\n    canDrag: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),\r\n\r\n    // Determine whether a node can be dropped based on its path and parents'.\r\n    canDrop: PropTypes.func,\r\n\r\n    // Called after children nodes collapsed or expanded.\r\n    onVisibilityToggle: PropTypes.func,\r\n\r\n    dndType: PropTypes.string,\r\n\r\n    // Prevent tree from rebuilding on dragging\r\n    freeze: PropTypes.bool\r\n};\r\n\r\nReactSortableTree.defaultProps = {\r\n    getNodeKey: defaultGetNodeKey,\r\n    nodeContentRenderer: NodeRendererDefault,\r\n    rowHeight: 62,\r\n    slideRegionSize: 100,\r\n    scaffoldBlockPxWidth: 44,\r\n    style: {},\r\n    innerStyle: {},\r\n    searchQuery: null,\r\n    isVirtualized: true,\r\n    canDrag: true,\r\n    freeze: false\r\n};\r\n\r\n// Export the tree component without the react-dnd DragDropContext,\r\n// for when component is used with other components using react-dnd.\r\n// see: https://github.com/gaearon/react-dnd/issues/186\r\nexport { ReactSortableTree as SortableTreeWithoutDndContext };\r\n\r\nexport default dndWrapRoot(ReactSortableTree);\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/react-sortable-tree.js","import React, { Component, Children, cloneElement } from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport styles from './tree-node.scss';\r\n\r\nclass TreeNode extends Component {\r\n    render() {\r\n        const {\r\n            children,\r\n            listIndex,\r\n            swapFrom,\r\n            swapLength,\r\n            swapDepth,\r\n            scaffoldBlockPxWidth,\r\n            lowerSiblingCounts,\r\n            connectDropTarget,\r\n            isOver,\r\n            draggedNode,\r\n            canDrop,\r\n            treeIndex,\r\n            customCanDrop: _customCanDrop, // Delete from otherProps\r\n            dragHover:     _dragHover,     // Delete from otherProps\r\n            getNodeKey:    _getNodeKey,    // Delete from otherProps\r\n            getPrevRow:    _getPrevRow,    // Delete from otherProps\r\n            maxDepth:      _maxDepth,      // Delete from otherProps\r\n            node:          _node,          // Delete from otherProps\r\n            path:          _path,          // Delete from otherProps\r\n            treeData:      _treeData,      // Delete from otherProps\r\n            ...otherProps,\r\n        } = this.props;\r\n\r\n        // Construct the scaffold representing the structure of the tree\r\n        const scaffoldBlockCount = lowerSiblingCounts.length;\r\n        const scaffold = [];\r\n        lowerSiblingCounts.forEach((lowerSiblingCount, i) => {\r\n            let lineClass = '';\r\n            if (lowerSiblingCount > 0) {\r\n                // At this level in the tree, the nodes had sibling nodes further down\r\n\r\n                if (listIndex === 0) {\r\n                    // Top-left corner of the tree\r\n                    // +-----+\r\n                    // |     |\r\n                    // |  +--+\r\n                    // |  |  |\r\n                    // +--+--+\r\n                    lineClass = `${styles.lineHalfHorizontalRight} ${styles.lineHalfVerticalBottom}`;\r\n                } else if (i === scaffoldBlockCount - 1) {\r\n                    // Last scaffold block in the row, right before the row content\r\n                    // +--+--+\r\n                    // |  |  |\r\n                    // |  +--+\r\n                    // |  |  |\r\n                    // +--+--+\r\n                    lineClass = `${styles.lineHalfHorizontalRight} ${styles.lineFullVertical}`;\r\n                } else {\r\n                    // Simply connecting the line extending down to the next sibling on this level\r\n                    // +--+--+\r\n                    // |  |  |\r\n                    // |  |  |\r\n                    // |  |  |\r\n                    // +--+--+\r\n                    lineClass = styles.lineFullVertical;\r\n                }\r\n            } else if (listIndex === 0) {\r\n                // Top-left corner of the tree, but has no siblings\r\n                // +-----+\r\n                // |     |\r\n                // |  +--+\r\n                // |     |\r\n                // +-----+\r\n                lineClass = styles.lineHalfHorizontalRight;\r\n            } else if (i === scaffoldBlockCount - 1) {\r\n                // The last or only node in this level of the tree\r\n                // +--+--+\r\n                // |  |  |\r\n                // |  +--+\r\n                // |     |\r\n                // +-----+\r\n                lineClass = `${styles.lineHalfVerticalTop} ${styles.lineHalfHorizontalRight}`;\r\n            }\r\n\r\n            scaffold.push(\r\n                <div\r\n                    key={`pre_${i}`}\r\n                    style={{ width: scaffoldBlockPxWidth }}\r\n                    className={`${styles.lineBlock} ${lineClass}`}\r\n                />\r\n            );\r\n\r\n            if (treeIndex !== listIndex && i === swapDepth) {\r\n                // This row has been shifted, and is at the depth of\r\n                // the line pointing to the new destination\r\n                let highlightLineClass = '';\r\n\r\n                if (listIndex === swapFrom + swapLength - 1) {\r\n                    // This block is on the bottom (target) line\r\n                    // This block points at the target block (where the row will go when released)\r\n                    highlightLineClass = styles.highlightBottomLeftCorner;\r\n                } else if (treeIndex === swapFrom) {\r\n                    // This block is on the top (source) line\r\n                    highlightLineClass = styles.highlightTopLeftCorner;\r\n                } else {\r\n                    // This block is between the bottom and top\r\n                    highlightLineClass = styles.highlightLineVertical;\r\n                }\r\n\r\n                scaffold.push(\r\n                    <div\r\n                        key={`highlight_${i}`}\r\n                        style={{\r\n                            width: scaffoldBlockPxWidth,\r\n                            left: scaffoldBlockPxWidth * i,\r\n                        }}\r\n                        className={`${styles.absoluteLineBlock} ${highlightLineClass}`}\r\n                    />\r\n                );\r\n            }\r\n        });\r\n\r\n        return connectDropTarget(\r\n            <div\r\n                {...otherProps}\r\n                className={styles.node}\r\n            >\r\n                {scaffold}\r\n\r\n                <div\r\n                    className={styles.nodeContent}\r\n                    style={{ left: scaffoldBlockPxWidth * scaffoldBlockCount }}\r\n                >\r\n                    {Children.map(children, child => cloneElement(child, {\r\n                        isOver,\r\n                        canDrop,\r\n                        draggedNode,\r\n                    }))}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nTreeNode.propTypes = {\r\n    treeIndex:            PropTypes.number.isRequired,\r\n    node:                 PropTypes.object.isRequired,\r\n    path:                 PropTypes.arrayOf(PropTypes.oneOfType([ PropTypes.string, PropTypes.number ])).isRequired,\r\n    swapFrom:             PropTypes.number,\r\n    swapDepth:            PropTypes.number,\r\n    swapLength:           PropTypes.number,\r\n    scaffoldBlockPxWidth: PropTypes.number.isRequired,\r\n    lowerSiblingCounts:   PropTypes.array.isRequired,\r\n\r\n    listIndex: PropTypes.number.isRequired,\r\n    children:  PropTypes.node,\r\n\r\n    // Drop target\r\n    connectDropTarget: PropTypes.func.isRequired,\r\n    isOver:            PropTypes.bool.isRequired,\r\n    canDrop:           PropTypes.bool,\r\n    draggedNode:       PropTypes.object,\r\n\r\n    customCanDrop: PropTypes.func,                      // used in drag-and-drop-utils\r\n    dragHover:     PropTypes.func.isRequired,           // used in drag-and-drop-utils\r\n    getNodeKey:    PropTypes.func,                      // used in drag-and-drop-utils\r\n    getPrevRow:    PropTypes.func,                      // used in drag-and-drop-utils\r\n    maxDepth:      PropTypes.number,                    // used in drag-and-drop-utils\r\n    treeData:      PropTypes.arrayOf(PropTypes.object), // used in drag-and-drop-utils\r\n};\r\n\r\nexport default TreeNode;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/tree-node.js","/**\r\n * Get the version of Internet Explorer in use, or undefined\r\n *\r\n * @return {?number} ieVersion - IE version as an integer, or undefined if not IE\r\n */\r\nexport function getIEVersion() {\r\n    const match = navigator.userAgent.match(/(?:MSIE |Trident\\/.*; rv:)(\\d+)/);\r\n    return match ? parseInt(match[1], 10) : undefined;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/browser-utils.js","import {\r\n    DragDropContext as dragDropContext,\r\n    DragSource as dragSource,\r\n    DropTarget as dropTarget,\r\n} from 'react-dnd';\r\nimport HTML5Backend from 'react-dnd-html5-backend';\r\nimport {\r\n    getDepth,\r\n} from './tree-data-utils';\r\nimport {\r\n    memoizedInsertNode,\r\n} from './memoized-tree-data-utils';\r\n\r\nconst nodeDragSource = {\r\n    beginDrag(props) {\r\n        props.startDrag(props);\r\n\r\n        return {\r\n            node:       props.node,\r\n            parentNode: props.parentNode,\r\n            path:       props.path,\r\n            treeIndex:  props.treeIndex,\r\n        };\r\n    },\r\n\r\n    endDrag(props, monitor) {\r\n        props.endDrag(monitor.getDropResult());\r\n    },\r\n\r\n    isDragging(props, monitor) {\r\n        const dropTargetNode = monitor.getItem().node;\r\n        const draggedNode    = props.node;\r\n\r\n        return draggedNode === dropTargetNode;\r\n    }\r\n};\r\n\r\nfunction getTargetDepth(dropTargetProps, monitor) {\r\n    let dropTargetDepth = 0;\r\n    const draggedItem = monitor.getItem();\r\n    const rowAbove = dropTargetProps.getPrevRow();\r\n    if (rowAbove) {\r\n        // Limit the length of the path to the deepest possible\r\n        dropTargetDepth = Math.min(rowAbove.path.length, dropTargetProps.path.length);\r\n    }\r\n\r\n    const blocksOffset = Math.round(\r\n        monitor.getDifferenceFromInitialOffset().x /\r\n        dropTargetProps.scaffoldBlockPxWidth\r\n    );\r\n\r\n    let targetDepth = Math.min(dropTargetDepth, Math.max(0, draggedItem.path.length + blocksOffset - 1));\r\n\r\n    // If a maxDepth is defined, constrain the target depth\r\n    if (typeof dropTargetProps.maxDepth !== 'undefined' && dropTargetProps.maxDepth !== null) {\r\n        const draggedNode       = monitor.getItem().node;\r\n        const draggedChildDepth = getDepth(draggedNode);\r\n\r\n        targetDepth = Math.min(targetDepth, dropTargetProps.maxDepth - draggedChildDepth - 1);\r\n    }\r\n\r\n    return targetDepth;\r\n}\r\n\r\nfunction canDrop(dropTargetProps, monitor) {\r\n    if (!monitor.isOver()) {\r\n        return false;\r\n    }\r\n\r\n    const rowAbove    = dropTargetProps.getPrevRow();\r\n    const abovePath   = rowAbove ? rowAbove.path : [];\r\n    const aboveNode   = rowAbove ? rowAbove.node : {};\r\n    const targetDepth = getTargetDepth(dropTargetProps, monitor);\r\n\r\n    // Cannot drop if we're adding to the children of the row above and\r\n    //  the row above is a function\r\n    if (targetDepth >= abovePath.length && typeof aboveNode.children === 'function') {\r\n        return false;\r\n    }\r\n\r\n    if (typeof dropTargetProps.customCanDrop === 'function') {\r\n        const node = monitor.getItem().node;\r\n        const addedResult = memoizedInsertNode({\r\n            treeData:         dropTargetProps.treeData,\r\n            newNode:          node,\r\n            depth:            targetDepth,\r\n            getNodeKey:       dropTargetProps.getNodeKey,\r\n            minimumTreeIndex: dropTargetProps.listIndex,\r\n            expandParent:     true,\r\n        });\r\n\r\n        return dropTargetProps.customCanDrop({\r\n            node,\r\n            prevPath:      monitor.getItem().path,\r\n            prevParent:    monitor.getItem().parentNode,\r\n            prevTreeIndex: monitor.getItem().treeIndex,\r\n            nextPath:      addedResult.path,\r\n            nextParent:    addedResult.parentNode,\r\n            nextTreeIndex: addedResult.treeIndex,\r\n        });\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nconst nodeDropTarget = {\r\n    drop(dropTargetProps, monitor) {\r\n        return {\r\n            node:             monitor.getItem().node,\r\n            path:             monitor.getItem().path,\r\n            minimumTreeIndex: dropTargetProps.treeIndex,\r\n            depth:            getTargetDepth(dropTargetProps, monitor),\r\n        };\r\n    },\r\n\r\n    hover(dropTargetProps, monitor) {\r\n        const targetDepth = getTargetDepth(dropTargetProps, monitor);\r\n        const draggedNode = monitor.getItem().node;\r\n        const needsRedraw = (\r\n            // Redraw if hovered above different nodes\r\n            dropTargetProps.node !== draggedNode ||\r\n            // Or hovered above the same node but at a different depth\r\n            targetDepth !== (dropTargetProps.path.length - 1)\r\n        );\r\n\r\n        if (!needsRedraw) {\r\n            return;\r\n        }\r\n\r\n        dropTargetProps.dragHover({\r\n            node:             draggedNode,\r\n            path:             monitor.getItem().path,\r\n            minimumTreeIndex: dropTargetProps.listIndex,\r\n            depth:            targetDepth,\r\n        });\r\n    },\r\n\r\n    canDrop,\r\n};\r\n\r\nfunction nodeDragSourcePropInjection(connect, monitor) {\r\n    return {\r\n        connectDragSource:  connect.dragSource(),\r\n        connectDragPreview: connect.dragPreview(),\r\n        isDragging:         monitor.isDragging(),\r\n        didDrop:            monitor.didDrop(),\r\n    };\r\n}\r\n\r\nfunction nodeDropTargetPropInjection(connect, monitor) {\r\n    const dragged = monitor.getItem();\r\n    return {\r\n        connectDropTarget: connect.dropTarget(),\r\n        isOver:            monitor.isOver(),\r\n        canDrop:           monitor.canDrop(),\r\n        draggedNode:       dragged ? dragged.node : null,\r\n    };\r\n}\r\n\r\nexport function dndWrapSource(el, type) {\r\n    return dragSource(type, nodeDragSource, nodeDragSourcePropInjection)(el);\r\n}\r\n\r\nexport function dndWrapTarget(el, type) {\r\n    return dropTarget(type, nodeDropTarget, nodeDropTargetPropInjection)(el);\r\n}\r\n\r\nexport function dndWrapRoot(el) {\r\n    return dragDropContext(HTML5Backend)(el);\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/drag-and-drop-utils.js","export function swapRows(rows, fromIndex, toIndex, count = 1) {\r\n    const rowsWithoutMoved = [\r\n        ...rows.slice(0, fromIndex),\r\n        ...rows.slice(fromIndex + count),\r\n    ];\r\n\r\n    return [\r\n        ...rowsWithoutMoved.slice(0, toIndex),\r\n        ...rows.slice(fromIndex, fromIndex + count),\r\n        ...rowsWithoutMoved.slice(toIndex),\r\n    ];\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/generic-utils.js","exports = module.exports = require(\"../css-loader/lib/css-base.js\")(undefined);\n// imports\n\n\n// module\nexports.push([module.id, \".ReactVirtualized__Table__headerRow{font-weight:700;text-transform:uppercase}.ReactVirtualized__Table__headerRow,.ReactVirtualized__Table__row{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-direction:row;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;-ms-flex-align:center;-webkit-box-align:center;align-items:center}.ReactVirtualized__Table__headerTruncatedText{display:inline-block;max-width:100%;white-space:nowrap;text-overflow:ellipsis;overflow:hidden}.ReactVirtualized__Table__headerColumn,.ReactVirtualized__Table__rowColumn{margin-right:10px;min-width:0}.ReactVirtualized__Table__rowColumn{text-overflow:ellipsis;white-space:nowrap}.ReactVirtualized__Table__headerColumn:first-of-type,.ReactVirtualized__Table__rowColumn:first-of-type{margin-left:10px}.ReactVirtualized__Table__sortableHeaderColumn{cursor:pointer}.ReactVirtualized__Table__sortableHeaderIconContainer{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-align:center;-webkit-box-align:center;align-items:center}.ReactVirtualized__Table__sortableHeaderIcon{-ms-flex:0 0 24px;-webkit-box-flex:0;flex:0 0 24px;height:1em;width:1em;fill:currentColor}\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?-autoprefixer!./~/postcss-loader!./~/react-virtualized/styles.css\n// module id = 14\n// module chunks = 0","exports = module.exports = require(\"../node_modules/css-loader/lib/css-base.js\")(undefined);\n// imports\n\n\n// module\nexports.push([module.id, \".rst__rowWrapper{padding:10px 10px 10px 0;height:100%;box-sizing:border-box}.rst__row{height:100%;white-space:nowrap;display:-webkit-box;display:-ms-flexbox;display:flex}.rst__row>*{box-sizing:border-box}.rst__rowCancelPad,.rst__rowLandingPad{border:none!important;box-shadow:none!important;outline:none!important}.rst__rowCancelPad *,.rst__rowLandingPad *{opacity:0!important}.rst__rowCancelPad:before,.rst__rowLandingPad:before{background-color:#add8e6;border:3px dashed #fff;content:\\\"\\\";position:absolute;top:0;right:0;bottom:0;left:0;z-index:-1}.rst__rowCancelPad:before{background-color:#e6a8ad}.rst__rowSearchMatch{outline:3px solid #0080ff}.rst__rowSearchFocus{outline:3px solid #fc6421}.rst__loadingHandle,.rst__moveHandle,.rst__rowContents,.rst__rowLabel,.rst__rowLabel_NoFlex,.rst__rowToolbar,.rst__rowToolbar_NoFlex,.rst__toolbarButton{display:inline-block;vertical-align:middle}.rst__rowContents{position:relative;height:100%;border:1px solid #bbb;border-left:none;box-shadow:0 2px 2px -2px;padding:0 5px 0 10px;border-radius:2px;min-width:230px;-webkit-box-flex:1;-ms-flex:1 0 auto;flex:1 0 auto;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;background-color:#fff}.rst__rowContentsDragDisabled{border-left:1px solid #bbb}.rst__rowLabel{padding-right:20px}.rst__rowLabel,.rst__rowToolbar{-webkit-box-flex:0;-ms-flex:0 1 auto;flex:0 1 auto}.rst__rowToolbar{display:-webkit-box;display:-ms-flexbox;display:flex}.rst__loadingHandle,.rst__moveHandle{height:100%;width:44px;background:#d9d9d9 url(\\\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0MiIgaGVpZ2h0PSI0MiI+PGcgc3Ryb2tlPSIjRkZGIiBzdHJva2Utd2lkdGg9IjIuOSIgPjxwYXRoIGQ9Ik0xNCAxNS43aDE0LjQiLz48cGF0aCBkPSJNMTQgMjEuNGgxNC40Ii8+PHBhdGggZD0iTTE0IDI3LjFoMTQuNCIvPjwvZz4KPC9zdmc+\\\") no-repeat 50%;border:1px solid #aaa;box-shadow:0 2px 2px -2px;cursor:move;border-radius:1px;z-index:1}.rst__loadingHandle{cursor:default;background:#d9d9d9}@-webkit-keyframes rst__pointFade{0%,19.999%,to{opacity:0}20%{opacity:1}}@keyframes rst__pointFade{0%,19.999%,to{opacity:0}20%{opacity:1}}.rst__loadingCircle{width:80%;height:80%;margin:10%;position:relative}.rst__loadingCirclePoint{width:100%;height:100%;position:absolute;left:0;top:0}.rst__loadingCirclePoint:before{content:\\\"\\\";display:block;margin:0 auto;width:11%;height:30%;background-color:#fff;border-radius:30%;-webkit-animation:rst__pointFade .8s infinite ease-in-out both;animation:rst__pointFade .8s infinite ease-in-out both}.rst__loadingCirclePoint:first-of-type{-webkit-transform:rotate(0deg);-ms-transform:rotate(0deg);transform:rotate(0deg)}.rst__loadingCirclePoint:first-of-type:before,.rst__loadingCirclePoint:nth-of-type(7):before{-webkit-animation-delay:-.8s;animation-delay:-.8s}.rst__loadingCirclePoint:nth-of-type(2){-webkit-transform:rotate(30deg);-ms-transform:rotate(30deg);transform:rotate(30deg)}.rst__loadingCirclePoint:nth-of-type(8){-webkit-transform:rotate(210deg);-ms-transform:rotate(210deg);transform:rotate(210deg)}.rst__loadingCirclePoint:nth-of-type(2):before,.rst__loadingCirclePoint:nth-of-type(8):before{-webkit-animation-delay:-666.66667ms;animation-delay:-666.66667ms}.rst__loadingCirclePoint:nth-of-type(3){-webkit-transform:rotate(60deg);-ms-transform:rotate(60deg);transform:rotate(60deg)}.rst__loadingCirclePoint:nth-of-type(9){-webkit-transform:rotate(240deg);-ms-transform:rotate(240deg);transform:rotate(240deg)}.rst__loadingCirclePoint:nth-of-type(3):before,.rst__loadingCirclePoint:nth-of-type(9):before{-webkit-animation-delay:-.53333333s;animation-delay:-.53333333s}.rst__loadingCirclePoint:nth-of-type(4){-webkit-transform:rotate(90deg);-ms-transform:rotate(90deg);transform:rotate(90deg)}.rst__loadingCirclePoint:nth-of-type(10){-webkit-transform:rotate(270deg);-ms-transform:rotate(270deg);transform:rotate(270deg)}.rst__loadingCirclePoint:nth-of-type(4):before,.rst__loadingCirclePoint:nth-of-type(10):before{-webkit-animation-delay:-.4s;animation-delay:-.4s}.rst__loadingCirclePoint:nth-of-type(5){-webkit-transform:rotate(120deg);-ms-transform:rotate(120deg);transform:rotate(120deg)}.rst__loadingCirclePoint:nth-of-type(11){-webkit-transform:rotate(300deg);-ms-transform:rotate(300deg);transform:rotate(300deg)}.rst__loadingCirclePoint:nth-of-type(5):before,.rst__loadingCirclePoint:nth-of-type(11):before{-webkit-animation-delay:-.26666667s;animation-delay:-.26666667s}.rst__loadingCirclePoint:nth-of-type(6){-webkit-transform:rotate(150deg);-ms-transform:rotate(150deg);transform:rotate(150deg)}.rst__loadingCirclePoint:nth-of-type(12){-webkit-transform:rotate(330deg);-ms-transform:rotate(330deg);transform:rotate(330deg)}.rst__loadingCirclePoint:nth-of-type(6):before,.rst__loadingCirclePoint:nth-of-type(12):before{-webkit-animation-delay:-.13333333s;animation-delay:-.13333333s}.rst__loadingCirclePoint:nth-of-type(7){-webkit-transform:rotate(180deg);-ms-transform:rotate(180deg);transform:rotate(180deg)}.rst__loadingCirclePoint:nth-of-type(13){-webkit-transform:rotate(1turn);-ms-transform:rotate(1turn);transform:rotate(1turn)}.rst__loadingCirclePoint:nth-of-type(7):before,.rst__loadingCirclePoint:nth-of-type(13):before{-webkit-animation-delay:0ms;animation-delay:0ms}.rst__rowTitle{font-weight:700}.rst__rowTitleWithSubtitle{font-size:85%;display:block;height:.8rem}.rst__rowSubtitle{font-size:70%;line-height:1}.rst__collapseButton,.rst__expandButton{-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;position:absolute;border-radius:100%;box-shadow:0 0 0 1px #000;width:16px;height:16px;top:50%;-webkit-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);transform:translate(-50%,-50%);cursor:pointer}.rst__collapseButton:focus,.rst__expandButton:focus{outline:none;box-shadow:0 0 0 1px #000,0 0 1px 3px #83bef9}.rst__collapseButton:hover:not(:active),.rst__expandButton:hover:not(:active){background-size:24px;height:20px;width:20px}.rst__collapseButton{background:#fff url(\\\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOCIgaGVpZ2h0PSIxOCI+PGNpcmNsZSBjeD0iOSIgY3k9IjkiIHI9IjgiIGZpbGw9IiNGRkYiLz48ZyBzdHJva2U9IiM5ODk4OTgiIHN0cm9rZS13aWR0aD0iMS45IiA+PHBhdGggZD0iTTQuNSA5aDkiLz48L2c+Cjwvc3ZnPg==\\\") no-repeat 50%}.rst__expandButton{background:#fff url(\\\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOCIgaGVpZ2h0PSIxOCI+PGNpcmNsZSBjeD0iOSIgY3k9IjkiIHI9IjgiIGZpbGw9IiNGRkYiLz48ZyBzdHJva2U9IiM5ODk4OTgiIHN0cm9rZS13aWR0aD0iMS45IiA+PHBhdGggZD0iTTQuNSA5aDkiLz48cGF0aCBkPSJNOSA0LjV2OSIvPjwvZz4KPC9zdmc+\\\") no-repeat 50%}.rst__row_NoFlex:before,.rst__rowContents_NoFlex:before{content:\\\"\\\";display:inline-block;vertical-align:middle;height:100%}.rst__rowContents_NoFlex{display:inline-block}.rst__rowContents_NoFlex:after{content:\\\"\\\";display:inline-block;width:100%}.rst__rowLabel_NoFlex{width:50%}.rst__rowToolbar_NoFlex{text-align:right;width:50%}.rst__lineChildren{height:100%;display:inline-block;position:absolute}.rst__lineChildren:after{content:\\\"\\\";position:absolute;background-color:#000;width:1px;left:50%;bottom:0;height:10px}\", \"\"]);\n\n// exports\nexports.locals = {\n\t\"rowWrapper\": \"rst__rowWrapper\",\n\t\"row\": \"rst__row\",\n\t\"rowLandingPad\": \"rst__rowLandingPad\",\n\t\"rowCancelPad\": \"rst__rowCancelPad\",\n\t\"rowSearchMatch\": \"rst__rowSearchMatch\",\n\t\"rowSearchFocus\": \"rst__rowSearchFocus\",\n\t\"rowContents\": \"rst__rowContents\",\n\t\"rowLabel\": \"rst__rowLabel\",\n\t\"rowToolbar\": \"rst__rowToolbar\",\n\t\"moveHandle\": \"rst__moveHandle\",\n\t\"loadingHandle\": \"rst__loadingHandle\",\n\t\"toolbarButton\": \"rst__toolbarButton\",\n\t\"rowLabel_NoFlex\": \"rst__rowLabel_NoFlex\",\n\t\"rowToolbar_NoFlex\": \"rst__rowToolbar_NoFlex\",\n\t\"rowContentsDragDisabled\": \"rst__rowContentsDragDisabled\",\n\t\"loadingCircle\": \"rst__loadingCircle\",\n\t\"loadingCirclePoint\": \"rst__loadingCirclePoint\",\n\t\"pointFade\": \"rst__pointFade\",\n\t\"rowTitle\": \"rst__rowTitle\",\n\t\"rowTitleWithSubtitle\": \"rst__rowTitleWithSubtitle\",\n\t\"rowSubtitle\": \"rst__rowSubtitle\",\n\t\"collapseButton\": \"rst__collapseButton\",\n\t\"expandButton\": \"rst__expandButton\",\n\t\"row_NoFlex\": \"rst__row_NoFlex\",\n\t\"rowContents_NoFlex\": \"rst__rowContents_NoFlex\",\n\t\"lineChildren\": \"rst__lineChildren\"\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?modules&-autoprefixer&importLoaders=1&localIdentName=rst__[local]!./~/postcss-loader!./~/sass-loader!./src/node-renderer-default.scss\n// module id = 15\n// module chunks = 0","exports = module.exports = require(\"../node_modules/css-loader/lib/css-base.js\")(undefined);\n// imports\n\n\n// module\nexports.push([module.id, \".rst__tree{/*! This comment keeps Sass from deleting the empty rule */}.rst__virtualScrollOverride{overflow:auto!important}.rst__virtualScrollOverride *{box-sizing:border-box}.ReactVirtualized__Grid__innerScrollContainer{overflow:visible!important}.ReactVirtualized__Grid{outline:none}\", \"\"]);\n\n// exports\nexports.locals = {\n\t\"tree\": \"rst__tree\",\n\t\"virtualScrollOverride\": \"rst__virtualScrollOverride\"\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?modules&-autoprefixer&importLoaders=1&localIdentName=rst__[local]!./~/postcss-loader!./~/sass-loader!./src/react-sortable-tree.scss\n// module id = 16\n// module chunks = 0","exports = module.exports = require(\"../node_modules/css-loader/lib/css-base.js\")(undefined);\n// imports\n\n\n// module\nexports.push([module.id, \".rst__node{min-width:100%;white-space:nowrap;position:relative}.rst__nodeContent{position:absolute;top:0;bottom:0}.rst__absoluteLineBlock,.rst__lineBlock{height:100%;position:relative;display:inline-block}.rst__absoluteLineBlock{position:absolute;top:0}.rst__lineFullVertical:after,.rst__lineHalfHorizontalRight:before,.rst__lineHalfVerticalBottom:after,.rst__lineHalfVerticalTop:after{position:absolute;content:\\\"\\\";background-color:#000}.rst__lineHalfHorizontalRight:before{height:1px;top:50%;right:0;width:50%}.rst__lineFullVertical:after,.rst__lineHalfVerticalBottom:after,.rst__lineHalfVerticalTop:after{width:1px;left:50%;top:0;height:100%}.rst__lineHalfVerticalBottom:after,.rst__lineHalfVerticalTop:after{top:0;height:50%}.rst__lineHalfVerticalBottom:after{top:auto;bottom:0}.rst__highlightLineVertical{z-index:3}.rst__highlightLineVertical:before{position:absolute;content:\\\"\\\";background-color:#36c2f6;width:8px;margin-left:-4px;left:50%;top:0;height:100%}@-webkit-keyframes rst__arrow-pulse{0%{-webkit-transform:translate(0);transform:translate(0);opacity:0}30%{-webkit-transform:translateY(300%);transform:translateY(300%);opacity:1}70%{-webkit-transform:translateY(700%);transform:translateY(700%);opacity:1}to{-webkit-transform:translateY(1000%);transform:translateY(1000%);opacity:0}}@keyframes rst__arrow-pulse{0%{-webkit-transform:translate(0);transform:translate(0);opacity:0}30%{-webkit-transform:translateY(300%);transform:translateY(300%);opacity:1}70%{-webkit-transform:translateY(700%);transform:translateY(700%);opacity:1}to{-webkit-transform:translateY(1000%);transform:translateY(1000%);opacity:0}}.rst__highlightLineVertical:after{content:\\\"\\\";position:absolute;height:0;margin-left:-4px;left:50%;top:0;border-left:4px solid transparent;border-right:4px solid transparent;border-top:4px solid #fff;-webkit-animation:rst__arrow-pulse 1s infinite linear both;animation:rst__arrow-pulse 1s infinite linear both}.rst__highlightTopLeftCorner:before{z-index:3;content:\\\"\\\";position:absolute;border-top:8px solid #36c2f6;border-left:8px solid #36c2f6;box-sizing:border-box;height:calc(50% + 4px);top:50%;margin-top:-4px;right:0;width:calc(50% + 4px)}.rst__highlightBottomLeftCorner{z-index:3}.rst__highlightBottomLeftCorner:before{content:\\\"\\\";position:absolute;border-bottom:8px solid #36c2f6;border-left:8px solid #36c2f6;box-sizing:border-box;height:calc(100% + 4px);top:0;right:12px;width:calc(50% - 8px)}.rst__highlightBottomLeftCorner:after{content:\\\"\\\";position:absolute;height:0;right:0;top:100%;margin-top:-12px;border-top:12px solid transparent;border-bottom:12px solid transparent;border-left:12px solid #36c2f6}\", \"\"]);\n\n// exports\nexports.locals = {\n\t\"node\": \"rst__node\",\n\t\"nodeContent\": \"rst__nodeContent\",\n\t\"lineBlock\": \"rst__lineBlock\",\n\t\"absoluteLineBlock\": \"rst__absoluteLineBlock\",\n\t\"lineHalfHorizontalRight\": \"rst__lineHalfHorizontalRight\",\n\t\"lineFullVertical\": \"rst__lineFullVertical\",\n\t\"lineHalfVerticalTop\": \"rst__lineHalfVerticalTop\",\n\t\"lineHalfVerticalBottom\": \"rst__lineHalfVerticalBottom\",\n\t\"highlightLineVertical\": \"rst__highlightLineVertical\",\n\t\"arrow-pulse\": \"rst__arrow-pulse\",\n\t\"highlightTopLeftCorner\": \"rst__highlightTopLeftCorner\",\n\t\"highlightBottomLeftCorner\": \"rst__highlightBottomLeftCorner\"\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader?modules&-autoprefixer&importLoaders=1&localIdentName=rst__[local]!./~/postcss-loader!./~/sass-loader!./src/tree-node.scss\n// module id = 17\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../css-loader/index.js?-autoprefixer!../postcss-loader/index.js!./styles.css\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!../style-loader/addStyles.js\")(content, {\"insertAt\":\"top\"});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../css-loader/index.js?-autoprefixer!../postcss-loader/index.js!./styles.css\", function() {\n\t\t\tvar newContent = require(\"!!../css-loader/index.js?-autoprefixer!../postcss-loader/index.js!./styles.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/react-virtualized/styles.css\n// module id = 18\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../node_modules/css-loader/index.js?modules&-autoprefixer&importLoaders=1&localIdentName=rst__[local]!../node_modules/postcss-loader/index.js!../node_modules/sass-loader/index.js!./node-renderer-default.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!../node_modules/style-loader/addStyles.js\")(content, {\"insertAt\":\"top\"});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../node_modules/css-loader/index.js?modules&-autoprefixer&importLoaders=1&localIdentName=rst__[local]!../node_modules/postcss-loader/index.js!../node_modules/sass-loader/index.js!./node-renderer-default.scss\", function() {\n\t\t\tvar newContent = require(\"!!../node_modules/css-loader/index.js?modules&-autoprefixer&importLoaders=1&localIdentName=rst__[local]!../node_modules/postcss-loader/index.js!../node_modules/sass-loader/index.js!./node-renderer-default.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/node-renderer-default.scss\n// module id = 19\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../node_modules/css-loader/index.js?modules&-autoprefixer&importLoaders=1&localIdentName=rst__[local]!../node_modules/postcss-loader/index.js!../node_modules/sass-loader/index.js!./react-sortable-tree.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!../node_modules/style-loader/addStyles.js\")(content, {\"insertAt\":\"top\"});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../node_modules/css-loader/index.js?modules&-autoprefixer&importLoaders=1&localIdentName=rst__[local]!../node_modules/postcss-loader/index.js!../node_modules/sass-loader/index.js!./react-sortable-tree.scss\", function() {\n\t\t\tvar newContent = require(\"!!../node_modules/css-loader/index.js?modules&-autoprefixer&importLoaders=1&localIdentName=rst__[local]!../node_modules/postcss-loader/index.js!../node_modules/sass-loader/index.js!./react-sortable-tree.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/react-sortable-tree.scss\n// module id = 20\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../node_modules/css-loader/index.js?modules&-autoprefixer&importLoaders=1&localIdentName=rst__[local]!../node_modules/postcss-loader/index.js!../node_modules/sass-loader/index.js!./tree-node.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!../node_modules/style-loader/addStyles.js\")(content, {\"insertAt\":\"top\"});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../node_modules/css-loader/index.js?modules&-autoprefixer&importLoaders=1&localIdentName=rst__[local]!../node_modules/postcss-loader/index.js!../node_modules/sass-loader/index.js!./tree-node.scss\", function() {\n\t\t\tvar newContent = require(\"!!../node_modules/css-loader/index.js?modules&-autoprefixer&importLoaders=1&localIdentName=rst__[local]!../node_modules/postcss-loader/index.js!../node_modules/sass-loader/index.js!./tree-node.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/tree-node.scss\n// module id = 21\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_22__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash.isequal\"\n// module id = 22\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_23__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"react-dnd\"\n// module id = 23\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_24__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"react-dnd-html5-backend\"\n// module id = 24\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_25__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"react-dnd-scrollzone\"\n// module id = 25\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_26__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"react-virtualized\"\n// module id = 26\n// module chunks = 0"],"sourceRoot":""}